# 计算机网络

### 1.OSI和TCP/IP网络分层模型详解

#### 1.OSI七层模型

OSI七层模型是国际标准化组织提出一个网络分层模型。每一层都专注地做一件事，并且每一层都需要使用下一层提供的功能：ex.传输层需要使用网络层提供的路由和寻址功能，这样数据层才知道把数据传输到哪。**OSI的七层体系结构概念清楚，理论也很完整，但是它比较复杂且不实用，有些功能在多个层中多次出现。**

```
应用层--------------------为计算机用户提供服务
表示层--------------------数据处理（编解码、加密解密、压缩解压缩）
会话层--------------------管理（建立、维护、重连）应用程序之间的回话
传输层--------------------为两台主机进程之间的通信提供通用的数据传输服务
网络层---------------------路由和寻址（决定数据在网络的游走路径）
数据链路层-----------------帧编码和误差纠正
物理层---------------------透明传输比特流
```

![image-20240302093442194](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302093442194.png)

OSI七层模型的问题：

- OSI的专家缺乏实际经验，在完成OSI标准时缺乏商业驱动力。
- OSI的协议实现过分复杂，运行效率很低
- OSI制定标准周期太长，无法及时进入市场
- OSI的层次划分不太合理，有些功能多个层次中重复出现

![img](https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-model-detail.png)

#### 2.TCP/IP四层模型

TCP/IP四层模型是目前被广泛采用的一种模型，由四层组成：**应用层、传输层、网络层、网络接口层**

```
1.应用层--------------------为计算机用户提供服务
1.表示层--------------------数据处理（编解码、加密解密、压缩解压缩）
1.会话层--------------------管理（建立、维护、重连）应用程序之间的回话
2.传输层-----------------为两台主机进程之间的通信提供通用的数据传输服务
3.网络层---------------------路由和寻址（决定数据在网络的游走路径）
4.数据链路层-----------------帧编码和误差纠正
4.物理层---------------------透明传输比特流
```

##### 应用层（Application layer)

**应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。**应用层交互的数据单元称为**报文**。

![image-20240302094622448](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302094622448.png)

**HTTP(Hypertext Transfer Protocol,超文本传输协议)**：基于TCP协议，是一种传输超文本和多媒体内容的协议，主要为web浏览器与web服务器之间的通信而设计。

**SMTP（Simple Mail Transfer Protol,简单邮件发送协议）**：基于TCP协议，是一种用于发送电子邮件的协议。只负责发送协议。

**POP3/IMAP（邮件接收协议）**：基于TCP协议，二者都是负责邮件接收的协议。IMAP协议是比POP3更新的协议，它的功能和性能上都更加强大。IMAP支持邮件搜索、标记、分类、归档等高级功能。而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务端都支持IMAP。

**FTP（File Transfer Protol,文件传输协议)**：基于TCP协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。【FTP是一种不安全的协议，它在传输过程中不会对数据进行加密；建议在传输敏感数据时使用更安全的协议，SFTP）

**Telent(远程登录协议)**：基于TCP协议，用户通过一个终端登录到其他服务器。其最大的缺点是：所有数据（包括用户名和密码）均以明文形式发送，有潜在的安全风险。因此如今更多人采用的是SSH协议。

**SSH（Secure Shell Protocol,安全的网络传输协议）**：基于TCP协议，通过加密和认证机制实现安全的访问和文件传输等业务。

**RTP（Real-time Transport Protocol,实时传输协议）**：通常基于UDP协议，但也支持TCP协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由WebRTC实现

**DNS（Domain Name System,域名管理系统**）：基于UDP协议，用于解决域名和IP地址的映射问题。

##### 传输层（Transport layer)

**传输层的主要任务是负责向两台终端设备进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层 报文。“通用的”是指并不针对某一个特定的网络应用，而是多种网络应用可以使用同一个运输层服务。

![image-20240302100920050](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302100920050.png)

- **TCP（Transmission Control Protocol，传输控制协议)**：提供**面向连接**的，**可靠**的数据传输服务。
- **UDP(User Datagram Protocol,用户数据协议)**：**提供无连接的**，**尽最大努力**的数据传输服务（不保证数据传输的可靠性），简单高效。
  - TCP 协议
    - 报文段结构
    - 可靠数据传输
    - 流量控制
    - 拥塞控制
  - UDP 协议
    - 报文段结构
    - RDT（可靠数据传输协议）

##### 网络层（Network layer）

**网络层负责为分组交换网上的不同主机提供通信服务**。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此**分组也叫IP数据报，简称数据报**。

**网络层还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到主机。**

互联网是由大量的异构（heterogeneous)网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol)和许多路由选择协议，因此**互联网的网络层也叫做网际层或IP层**。

![image-20240302101922334](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302101922334.png)

- **IP(Internet Protocol,网际协议)：**TCP/IP协议中最重要的协议之一，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便他们可以跨网络传播并到达正确的目的地。目前协议主要分为两种：IPv4和IPv6.
- **ARP（Address Resolution Protocol,地址解析协议）：**ARP协议解决的是网络层地址和链路层地址之间的转换问题。因为一个IP数据报在物理上传输的过程中，总是需要知道下一跳（物理的下一个目的地）该去往何处，但IP地址属于逻辑地址，MAC地址才是物理地址，ARP协议解决了IP地址转MAC地址的一些问题。
- **ICMP（Internet Control Message Protocol,互联网控制报文协议):**一种用于传输网络状态和错误消息的协议，常用语网络诊断和故障排除。ex:ping工具就是用了ICMP协议来测试网络的连通性。
- **NAT(Network Address Translation,网络地址转换协议)：**NAT协议应用于内部网到外部网的地址转换过程中。在LAN中，各主机使用的是同一个LAN下的IP地址，但在WAN中，需要一个统一的IP地址来标识该LAN在整个Internet上的位置。
- **OSPF（Open Shortest Path First,开放式最短路径优先）：**一种内部网关协议（IGP，Interior Gateway Protocol),也是使用最广泛的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。
- **RIP（Routing Information Protocol,路由信息协议）：**一种内部网关协议（IGP，Interior Gateway Protocol),也是使用最广泛的一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。
- **BGP（Border Gateway Protocol,边界网关协议）：**一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information ,NLRI)的路由选择协议，具有高度的灵活性和可扩展性。

##### 网络接口层（Network interface layer)

可以把网络接口层看做是数据链路层和物理层的结合体。

1.数据链路层（data link layer）简称链路层（两台主机之间的数据传输，总是在一段一段的链路上传送）。**数据链路层的作用是将网络层交下来的IP数据报组装成帧，在两个相邻的节点间的链路上传送帧。每一个帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制）。**

2.**物理层的作用是实现相邻计算机节点之间的比特流的透明传输，尽可能屏蔽掉具体传输介质和物理设备的差异。**

![image-20240302104216214](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302104216214.png)

- 差错检测技术
- 多路访问协议（信道复用技术）
- CSMA/CD 协议
- MAC 协议
- 以太网技术

#### 3.网络分层的原因

- **各层之间相互独立:**各层之间相互独立，各层之间不需要关注其它层如何实现，只需要知道自己如何调用下层提供好的功能就可以。
- **提高了整体的灵活性：**每一层都使用最合适的技术来实现，只需要保证提供的功能以及暴露的接口的规则没有改变即可。【高内聚，低耦合】
- **大问题化小：**将复杂的网络问题分解为许多较小的、界线比较清晰简单的小问题来处理和解决问题。

### 2.访问网页的全过程

![image-20240302105411566](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302105411566.png)

完整的流程：

1.在浏览器中输入指定网页的URL

2.浏览器通过DNS协议，获取域名对应的IP地址

3.浏览器根据IP地址和端口号，向目标服务器发起一个TCP连接请求

4.浏览器在TCP连接上，向服务器发送一个HTTP请求报文，请求获取网页的内容

5.浏览器收到HTTP请求报文后，处理请求，并返回Http响应报文给浏览器

6.浏览器收到HTTP响应报文后，解析响应体中的HTML代码，渲染网页的结构和样式，同时根据HTML中的其他资源的URL，再次发起HTTP请求，获取这些资源的内容，直到网页完全加载显示

7.浏览器在不需要和服务器通信时，可以主动关闭TCP连接，或者等待服务器的关闭请求。

**URL（Uniform Resource Locators），即统一资源定位器。**

![URL的组成结构](https://oss.javaguide.cn/github/javaguide/cs-basics/network/URL-parts.png)

1、协议:URL的前缀通常表示该网址采用了何种应用层协议。【HTTP/HTTPS】

2、域名：访问地址的通用名，也可能是网络的IP地址

3、端口：如果指明了访问网址的端口，端口会紧随域名之后，并用一个冒号隔开

4.资源路径：从第一个/开始，表示从服务器上根目录开始进行索引到文件路径

5.参数：是浏览器在向服务器提交请求时，在URL中附带的参数。参数采用键值对的形式key=value,每一个键值对使用&隔开。

6.锚点：访问的页面上的一个锚。在 URL 中，锚点以`#`开头，并且**不会**作为请求的一部分发送给服务端。

**网络层的的核心功能——转发与路由**，必会！！！

- 转发：将分组从路由器的输入端口转移到合适的输出端口。
- 路由：确定分组从源到目的经过的路径。

### 3.应用层常见协议总结

1.**超文本传输协议（HTTP，HyperText Transfer Protocol)** 是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。

HTTP 使用客户端-服务器模型，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应）HTTP 协议基于 TCP 协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。

2.**WebSocket 是一种基于 TCP 连接的全双工通信协议**，即客户端和服务器可以同时发送和接收数据。WebSocket 协议本质上是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

下面是 WebSocket 的常见应用场景：

- 视频弹幕
- 实时消息推送
- 实时游戏对战
- 多用户协同编辑
- 社交聊天

WebSocket 的工作过程可以分为以下几个步骤：

1. 客户端向服务器发送一个 HTTP 请求，请求头中包含 `Upgrade: websocket` 和 `Sec-WebSocket-Key` 等字段，表示要求升级协议为 WebSocket；
2. 服务器收到这个请求后，会进行升级协议的操作，如果支持 WebSocket，它将回复一个 HTTP 101 状态码，响应头中包含 ，`Connection: Upgrade`和 `Sec-WebSocket-Accept: xxx` 等字段、表示成功升级到 WebSocket 协议。
3. 客户端和服务器之间建立了一个 WebSocket 连接，可以进行双向的数据传输。数据以帧（frames）的形式进行传送，WebSocket 的每条消息可能会被切分成多个数据帧（最小单位）。发送端会将消息切割成多个帧发送给接收端，接收端接收消息帧，并将关联的帧重新组装成完整的消息。
4. 客户端或服务器可以主动发送一个关闭帧，表示要断开连接。另一方收到后，也会回复一个关闭帧，然后双方关闭 TCP 连接。

另外，建立 WebSocket 连接之后，通过心跳机制来保持 WebSocket 连接的稳定性和活跃性。

3.**简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）** 基于 TCP 协议，是一种用于发送电子邮件的协议。

**电子邮件的发送过程？**

比如我的邮箱是“[dabai@cszhinan.com](mailto:dabai@cszhinan.com)”，我要向“[xiaoma@qq.com](mailto:xiaoma@qq.com)”发送邮件，整个过程可以简单分为下面几步：

1. 通过 **SMTP** 协议，我将我写好的邮件交给 163 邮箱服务器（邮局）。
2. 163 邮箱服务器发现我发送的邮箱是 qq 邮箱，然后它使用 SMTP 协议将我的邮件转发到 qq 邮箱服务器。
3. qq 邮箱服务器接收邮件之后就通知邮箱为“[xiaoma@qq.com](mailto:xiaoma@qq.com)”的用户来收邮件，然后用户就通过 **POP3/IMAP** 协议将邮件取出。

**如何判断邮箱是真正存在的？**

这个时候我们可以利用 SMTP 协议来检测：

1. 查找邮箱域名对应的 SMTP 服务器地址
2. 尝试与服务器建立连接
3. 连接成功后尝试向需要验证的邮箱发送邮件
4. 根据返回结果判定邮箱地址的真实性

4. **POP3 和 IMAP 两者都是负责邮件接收的协议** 即可（二者也是基于 TCP 协议）

   IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP

5. F**TP 协议** 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。

   ```
   FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：控制连接：用于传送控制信息（命令和响应）数据连接：用于数据传送；这种将命令和数据分开传送的思想大大提高了 FTP 的效率。
   ```

   ![image-20240302214306523](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302214306523.png)

注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。因此，FTP 传输的文件可能会被窃听或篡改。建议在传输敏感数据时使用更安全的协议，如 SFTP（一种基于 SSH 协议的安全文件传输协议，用于在网络上安全地传输文件）。

6.**Telnet 协议** 基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。

7.**SSH（Secure Shell）** 基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。SSH 的经典用途是登录到远程电脑中执行命令。除此之外，SSH 也支持隧道协议、端口映射和 X11 连接。借助 SFTP 或 SCP 协议，SSH 还可以传输文件。SSH 使用客户端-服务器模型，默认端口是 22。SSH 是一个守护进程，负责实时监听客户端请求，并进行处理。大多数现代操作系统都提供了 SSH

**8.RTP（Real-time Transport Protocol，实时传输协议）**通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。

RTP 协议分为两种子协议：

- **RTP（Real-time Transport Protocol，实时传输协议）**：传输具有实时特性的数据。
- **RTCP（RTP Control Protocol，RTP 控制协议）**：提供实时传输过程中的统计信息（如网络延迟、丢包率等），WebRTC 正是根据这些信息处理丢包

**9.DNS（Domain Name System，域名管理系统）基于 UDP 协议**，用于解决域名和 IP 地址的映射问题。

### 4.HTTP VS HTTPS

**HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）**，主要是来规范浏览器和服务器端的行为的，HTTP 是一个无状态（stateless）协议，其优点是：扩展性强、速度快、跨平台支持性好。

HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：

1. 服务器在 80 端口等待客户的请求。
2. 浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。
3. 服务器接收来自浏览器的 TCP 连接。
4. 浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。
5. 关闭 TCP 连接。

**HTTPS 协议（Hyper Text Transfer Protocol Secure）**，是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特，其优点是：保密性好、信任度高。HTTPS 之所以能达到较高的安全性要求，就是结**合了 SSL/TLS 和 TCP 协议**，对通信数据进行加密，解决了 HTTP 数据透明的问题。

**SSL 和 TLS 没有太大的区别****。*：

SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，**新版本被命名为 TLS 1.0**。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 SSL/TLS。

**SSL/TLS的工作原理：**

1、**非对称加密**：SSL/TLS 的核心要素是**非对称加密**。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。

**2.对称加密**：使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。

```
对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。

对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密
```

总结来说，带有证书的公钥传输机制如下：

1. 设有服务器 S，客户端 C，和第三方信赖机构 CA。
2. S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。
3. S 获得 CA 颁发的证书，将该证书传递给 C。
4. C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。
5. 如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。

------

为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的**电子签名**（见下节）。

## [总结](#总结)

- **端口号**：HTTP 默认是 80，HTTPS 默认是 443。
- **URL 前缀**：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`。
- **安全性和资源消耗**：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。

### 5.HTTP1.0 VS HTTP 1.1

**1.连接方式：**HTTP 1.0 为短连接，HTTP 1.1 支持长连接

**2.状态响应码：**HTTP 1.1 中新加入了大量的状态码，光是错误响应状态码就新增了24种。ex:100（continue）--在请求大资源前的预热和请求，206（partial content）--范围请求的标识码，409（conflict）--请求与当前资源的规定冲突，410（gone）--资源已被永久转移，而且没有任何已知的转发地址。

**3.缓存处理：***(**缓存技术通过避免用户与源服务器的频繁交互，节约了大量的网络带宽，降低了用户接收信息的延迟)***在HTTP 1.0 中主要使用header里的if-modified-since，expires来作为缓存判断的标准，HTTP 1.1 则引入了更多的缓存控制策略。ex:entity tag,If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。

**4.带宽优化及网络连接的使用：**HTTP 1.0 中，存在浪费带宽现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能；HTTP 1.1 则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（partial content）,这样就方便开发者自由选择，以及充分利用带宽和连接。

**5.Host头处理：**HTTP 1.1 在请求头中加入了Host字段。

### 6.HTTP常见状态码总结

![image-20240302112419068](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302112419068.png)

**[2xx Success（成功状态码）](#_2xx-success-成功状态码)**

- **200 OK**：请求被成功处理。比如我们发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。
- **201 Created**：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。
- **202 Accepted**：服务端已经接收到了请求，但是还未处理。
- **204 No Content**：服务端已经成功处理了请求，但是没有返回任何内容

[3xx Redirection（重定向状态码）](#_3xx-redirection-重定向状态码)

- **301 Moved Permanently**：资源被永久重定向了。比如你的网站的网址更换了。
- **302 Found**：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。

[4xx Client Error（客户端错误状态码）](#_4xx-client-error-客户端错误状态码)

- **400 Bad Request**：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。
- **401 Unauthorized**：未认证却请求需要认证之后才能访问的资源。
- **403 Forbidden**：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。
- **404 Not Found**：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。
- **409 Conflict**：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。

[5xx Server Error（服务端错误状态码）](#_5xx-server-error-服务端错误状态码)

- **500 Internal Server Error**：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。
- **502 Bad Gateway**：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。

### 7.DNS域名解析系统

DNS（domain Name System)域名管理系统，是当用户使用浏览器访问网址之后，使用的一个重要协议。**DNS解决的是域名和IP地址的映射问题。**目前DNS的设计采用的是分布式、层次数据库结构、**DNS是应用层协议，基于UDP协议之上，端口为53.**

![image-20240302171752754](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302171752754.png)

所有的DNS服务器都属于以下四个分类之一：

- **根DNS服务器：**根DNS服务器提供TLD服务器的IP地址。我国境内目前仍然没有根服务器。【目前世界上并不只有13个根服务器，这13个IP地址中每一个由增加了多个服务器，截止2023年底，所有根服务器之和达到了600多台。
- **顶级域DNS服务器（TLD服务器）：**顶级域是指域名的后缀，如com、org、net和edu等。国家也有自己的顶级域，如UK、fr、ca。TLD服务器提供了权威DNS服务器的IP地址。
- **权威DNS服务器：**在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问得DNS记录，这些记录将这些主机的名字映射为IP地址。
- **本地DNS服务器：**每个ISP（互联网服务提供商）都有一个自己的本地DNS服务器。当主机发出DNS请求时，该请求被发往本地DNS服务器，起着代理作用，并将该请求转发到DNS层次结构中。【严格来说，不属于DNS层次结构】

**DNS的查询解析过程分为两种模式：递归和迭代**

![image-20240302173100909](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302173100909.png)

![image-20240302173121261](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302173121261.png)

递归可以提高 DNS 查询的效率和速度，减少对根服务器和 TLD 服务器的负担。

**DNS的报文格式**：DNS报文分为查询和回答报文，二者结构相同。

![image-20240302173228467](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302173228467.png)

- 标识符：16比特，用来标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收回答。
- 标志：1比特的“查询、回答”标志位，0表示查询报文，1表示回答报文。
- 问题数、回答RR数、权威RR数、附加RR数。分别指示后面4类数据区域出现的数量。
- 问题区域：包含正在被查询的主机的名字，以及正被询问的问题类型
- 回答区域：包含了对最初请求的名字的资源记录。**在回答报文的回答区域中可以包含多条RR，因此一个主机名能够有多个IP地址。**
- 权威区域：包含了其他权威服务器的记录
- 附加区域：包含了其他有帮助的记录

### 8.TCP三次握手和四次挥手

**三次握手的目的是建立可靠的通信信道，就是双方确认自己与对方的发送与接收是正常的。**

1.建立一个TCP连接需要“三次握手”，缺一不可：

- **一次握手：**客户端发送带有SYN（SEQ=x）标志的数据包到服务端，然后客户端进入SYN_SEND状态，等待服务器的确认。【client什么都不能确认，server确认了对方发送正常，自己接受正常】

- **二次握手：**服务端发送带有SYN+ACK(SEQ=y,ACK=x+1）标志的数据包到客户端，然后服务端进入SYN_RECV状态。【client确认了：自己发送、接收正常、对方发送、接收正常；server确认了：对方发送正常，自己接收正常】

- **三次握手：**客户端发送带有ACK（ACK=y+1)标志的数据包到服务端，然后客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。【Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常】

  ![image-20240302174435222](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302174435222.png)

2.**第二次握手传回了ACK，还要传回SYN是因为：**传送ACK是为了告诉客户端“我接受到的信息确实是你所发送的信号”，表明两个端口的通信是正常的。回传SYN则是为了建立并确认从服务端到客户端的通信。

```
SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。
```

3.T**CP是全双工通信，可以双向传输数据**。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放的通知，对方确认后就完全关闭了TCP连接。

断开一个TCP连接需要“四次挥手”，缺一不可：

- **第一次挥手：**客户端发送一个FIN（SEQ=X）标志的数据包到服务端，用来关闭客户端到服务器的数据传送。然后客户端进入FIN-WAIT-1状态。【client告诉对方无需要传送的数据了，等待1次】

- **第二次挥手：**服务器收到这个FIN（SEQ=x)标志的数据包，它发送一个ACK(ACK=x+1)标志的包到客户端。然后服务端进入CLOSE-WAIT状态，客户端进入FIN-WAIT-2状态。【server明确了对方的信息，但还需要传送数据，client等待2次】

- **第三次挥手：**服务端发送一个FIN(ACK=y+1)标志的数据包到客户端，请求关闭连接，然后服务端进入LAST-ACK状态。【server告诉对方数据传送完毕，发出最后的关闭确认消息】

- **第四次挥手：**客户端发送ACK(ACK=y+1)标志的数据包到服务端，然后客户端进入TIME-WAIT状态，服务端在接收到ACK(ACK=y+1)标志的数据包后进入CLOSE状态。此时客户端等待2MSL（Maximum Segment Lifetime的两倍）后依然没回复，证明服务端已正常关闭，其随之也关闭连接。【client发送确认消息，进入最后等待时间，server收到确认消息直接关闭。2msl没想赢后client关闭连接】

  ```
  MSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。
  ```

  ![image-20240302181028388](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302181028388.png)

4**.为什么不能把服务器发送的ACKhe FIN合并，成为三次挥手？**

因为服务器在收到客户端断开连接的请求时，肯还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。

**5.如果第二次挥手时服务器的ACK没有达到客户端，会怎么样？**

客户端没有收到ACK确认消息，会重新发送FIN请求。

**6.为什么第四次挥手客户端需要等2msl?**

第四次挥手的时候，客户端发送给服务器的ACK有可能丢失，如果服务端因为某些原因而没有收到ACK的话，服务端就会重新发送FIN，如果客户端在2MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止服务端没有收到ACK而不断重发FIN。

### 9.TCP可靠传输

#### 1.TCP如何保证传输的可靠性？

- **基于数据块传输：**应用数据包被分割成TCP认为最合适发送的数据块，再传输给网络层，数据块被称为报文段或段。
- **对失序数据包重新排序以及去重：**TCP为了保证不发生丢包，就给每个包一个序列号，收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。
- **校验和：**TCP将保持它首部和数据的校验和。这时一个端到端的校验和，目的是检测数据在传输过程中的任何变化。若有差错，则丢包。
- **重传机制：**在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答。【重传机制：基于计时器的重传（超时重传）、快速重传（基于接收端的反馈信息引发重传）、SACK（快速重传的技术上返回序列号范围）、D-SACK（重复SACK，再次基础上，告知重复接收的包）】
- **流量控制：**TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据时，能提示对方降低发送的频率，防止丢包。**TCP利用滑动窗口实现流量控制。**【即数据大于缓冲区，就减缓发送数据的速度】
- **拥塞控制：**当网络拥塞的时候，就减少数据的发送。TCP发送数据时要考虑：接收方的接受能力（滑动窗口表示）、网络的拥塞程度（拥塞窗口表示）。它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。【即数据大于拥塞窗口时，就减少发送数据的数量】

#### 2.TCP如何实现流量控制？

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

1.**为什么需要流量控制**？

因为双方在通信的时候，发送方的速率与接收方的速率不一定相等。如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 **接收缓冲区(Receiving Buffers)** 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。

**2.【发送端不等于客户端、接收端不等于服务端】**

因为TCP为全双工通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是接收端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口的大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同。

**3.TCP的发送窗口可以划分为四个部分：**

1. 已经发送并且确认的 TCP 段（已经发送并确认）；

2. 已经发送但是没有确认的 TCP 段（已经发送未确认）；

3. 未发送但是接收方准备接收的 TCP 段（可以发送）；

4. 未发送并且接收方也并未准备接受的 TCP 段（不可发送）。

   ![image-20240302184415195](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302184415195.png)

**4、TCP的接收窗口分为三个部分：**

1. 已经接收并且已经确认的 TCP 段（已经接收并确认）；

2. 等待接收且允许发送方发送 TCP 段（可以接收未确认）；

3. 不可接收且不允许发送方发送 TCP 段（不可接收）

   ![image-20240302184533049](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302184533049.png)

#### 3.TCP的拥塞控制是怎么实现的？

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫**拥塞**。**拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。**拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。

- **拥塞控制**是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。
- **流量控制**往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

![image-20240302184712411](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302184712411.png)

**TCP 的拥塞控制采用了四种算法：**

- **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。
- **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.
- **快重传与快恢复：** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作

#### 4.ARQ协议

**自动重传请求**（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。

**ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。**

**1.停止等待ARQ协议**

停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。

**2.连续ARQ协议**

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

- **优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。
- **缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。

#### 5.超时重传如何实现

当发送方发送数据之后，它启动一个定时器，等待目的端确认接收到这个报文段。接收端实体对已成功收到的包回一个相应确认的信息（ACK)。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为[已丢失】并进行重传。

- RTT（Round Trip Time）：往返时间，也就是数据包从发出去到收到对应 ACK 的时间。
- RTO（Retransmission Time Out）：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。

RTO 的确定是一个关键问题，因为它直接影响到 TCP 的性能和效率。如果 RTO 设置得太小，会导致不必要的重传，增加网络负担；如果 RTO 设置得太大，会导致数据传输的延迟，降低吞吐量。因此，RTO 应该根据网络的实际状况，动态地进行调整。

RTT 的值会随着网络的波动而变化，所以 TCP 不能直接使用 RTT 作为 RTO。为了动态地调整 RTO，TCP 协议采用了一些算法，如加权移动平均（EWMA）算法，Karn 算法，Jacobson 算法等，这些算法都是根据往返时延（RTT）的测量和变化来估计 RTO 的值。

### 10.ARP协议详解

**ARP 协议**，可以说是在协议栈中属于一个**偏底层的、非常重要的、又非常简单的**通信协议。

#### **1.ARP协议在协议栈中的位置？**

ARP协议在协议栈中的位置非常重要，它串联起来了网络层和链路层。国外的大部分教程通常将ARP协议放在网络层。

#### **2.ARP解决了什么问题？**

ARP协议，全程地址解析协议（Address Resolution Protocol),它解决的是网络层地址和链路层地址之间的转换问题。因为一个IP数据报在物理传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP协议解决了IP地址转M阿城地址的一些问题。

#### **3.ARP的工作原理？**

ARP表、广播问询、单播响应

ARP 的工作原理将分两种场景讨论：

**同一局域网内的 MAC 寻址**；

1. 主机 A 检索自己的 ARP 表，发现 ARP 表中并无主机 B 的 IP 地址对应的映射条目，也就无从知道主机 B 的 MAC 地址。

2. 主机 A 将构造一个 ARP 查询分组，并将其广播到所在的局域网中。

   ```
   ARP 分组是一种特殊报文，ARP 分组有两类，一种是查询分组，另一种是响应分组，它们具有相同的格式，均包含了发送和接收的 IP 地址、发送和接收的 MAC 地址。当然了，查询分组中，发送的 IP 地址，即为主机 A 的 IP 地址，接收的 IP 地址即为主机 B 的 IP 地址，发送的 MAC 地址也是主机 A 的 MAC 地址，但接收的 MAC 地址绝不会是主机 B 的 MAC 地址（因为这正是我们要问询的！），而是一个特殊值——FF-FF-FF-FF-FF-FF，之前说过，该 MAC 地址是广播地址，也就是说，查询分组将广播给该局域网内的所有设备。
   ```

3. 主机 A 构造的查询分组将在该局域网内广播，理论上，每一个设备都会收到该分组，并检查查询分组的接收 IP 地址是否为自己的 IP 地址，如果是，说明查询分组已经到达了主机 B，否则，该查询分组对当前设备无效，丢弃之。

4. 主机 B 收到了查询分组之后，验证是对自己的问询，接着构造一个 ARP 响应分组，该分组的目的地只有一个——主机 A，发送给主机 A。同时，主机 B 提取查询分组中的 IP 地址和 MAC 地址信息，在自己的 ARP 表中构造一条主机 A 的 IP-MAC 映射记录。

   ```
   ARP 响应分组具有和 ARP 查询分组相同的构造，不同的是，发送和接受的 IP 地址恰恰相反，发送的 MAC 地址为发送者本身，目标 MAC 地址为查询分组的发送者，也就是说，ARP 响应分组只有一个目的地，而非广播。
   ```

5. 主机 A 终将收到主机 B 的响应分组，提取出该分组中的 IP 地址和 MAC 地址后，构造映射信息，加入到自己的 ARP 表中。

   ![image-20240302213344406](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302213344406.png)

2.**从一个局域网到另一个局域网中的网络设备的寻址**。

1. 主机 A 查询 ARP 表，期望寻找到目标路由器的本子网接口的 MAC 地址。

2. 目标路由器指的是，根据目的主机 B 的 IP 地址，分析出 B 所在的子网，能够把报文转发到 B 所在子网的那个路由器。

3. 主机 A 未能找到目标路由器的本子网接口的 MAC 地址，将采用 ARP 协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同。

4. 主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是**本子网内与路由器连接的接口的 MAC 地址**。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口。

5. 目标接口接收到了主机 A 发过来的链路层帧，解析，根据目的 IP 地址，查询转发表，将该 IP 数据报转发到与主机 B 所在子网相连的接口上。

6. 到此，该帧已经从主机 A 所在的子网，转移到了主机 B 所在的子网了。

7. 路由器接口查询 ARP 表，期望寻找到主机 B 的 MAC 地址。

8. 路由器接口如未能找到主机 B 的 MAC 地址，将采用 ARP 协议，广播问询，单播响应，获取到主机 B 的 MAC 地址。

9. 路由器接口将对 IP 数据报重新封装成链路层帧，目标 MAC 地址为主机 B 的 MAC 地址，单播发送，直到目的地。

   ![image-20240302213501726](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302213501726.png)

#### 4.MAC地址

MAC地址的全称是 媒体访问控制地址（Media Access Control Address).是一切网络设备的唯一标识。是一个网络设备真正的身份证号。Mac地址也有一些别称，如LAN地址、物理地址、以太网地址。

Mac地址长度为6字节（48bite),地址空间大小有280万亿之多，MAC地址统一有IEEE统一管理和分配。MAC地址具有可携带性、永久性。MAC地址有一个特殊地址：FF-FF-FF-FF-FF-FF-FF（全1地址）该地址表示广播地址。

### 11.NAT协议详解

**NAT 协议（Network Address Translation）** 的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。家庭办公室（Small Office, Home Office, SOHO）SOHO 子网的“代理人”，也就是和外界的窗口，通常由路由器扮演。路由器的 LAN 一侧管理着一个小子网，而它的 WAN 接口才是真正参与到 Internet 中的接口，也就有一个“绝对唯一的地址”。NAT 协议，正是在 LAN 中的主机在与 LAN 外界通信时，起到了地址转换的关键作用。

![image-20240302213640027](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240302213640027.png)

总结 NAT 协议的特点，有以下几点：

1. NAT 协议通过对 WAN 屏蔽 LAN，有效地缓解了 IPv4 地址分配压力。
2. LAN 主机 IP 地址的变更，无需通告 WAN。
3. WAN 的 ISP 变更接口地址时，无需通告 LAN 内主机。
4. LAN 主机对 WAN 不可见，不可直接寻址，可以保证一定程度的安全性。

### 12.网络攻击常见手段

#### 1.IP欺骗

IP欺骗技术就是伪造某台主机的IP地址的技术。通过IP地址的伪装使得某台主机能够伪装另外一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。

**1.IP头部格式**

![image-20240303122410425](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240303122410425.png)

**2.如何缓解IP欺骗**

**入口过滤** 是防范欺骗的一种极为常见的防御措施，如 BCP38（通用最佳实践文档）所示。入口过滤是一种数据包过滤形式，通常在[网络边缘]设备上实施，用于检查传入的 IP 数据包并确定其源标头。如果这些数据包的源标头与其来源不匹配或者看上去很可疑，则拒绝这些数据包。一些网络还实施出口过滤，检查退出网络的 IP 数据包，确保这些数据包具有合法源标头，以防止网络内部用户使用 IP 欺骗技术发起出站恶意攻击。

#### 2.SYN Flood(洪水)

SYN Flood是互联网上最原始、最经典的DDOS（Distributed Denial of Service,分布式拒绝服务）攻击对象之一，旨在耗尽可用服务器资源，致使服务器无法传输合法流量。

SYN Flood 利用了 TCP 协议的三次握手机制，攻击者通常利用工具或者控制僵尸主机向服务器发送海量的变源 IP 地址或变源端口的 TCP SYN 报文，服务器响应了这些报文后就会生成大量的半连接，当系统资源被耗尽后，服务器将无法提供正常的服务。
 增加服务器性能，提供更多的连接能力对于 SYN Flood 的海量报文来说杯水车薪，防御 SYN Flood 的关键在于判断哪些连接请求来自于真实源，屏蔽非真实源的请求以保障正常的业务请求能得到服务。

![image-20240303123223718](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240303123223718.png)

**1.TCP SYN Flood攻击原理是什么？**

**TCP SYN Flood** 攻击利用的是 **TCP** 的三次握手（**SYN -> SYN/ACK -> ACK**）。正常情况下，状态的确认主要是双方将要使用的**消息序号(\**SequenceNum)，\*\*TCP\*\* 为保证消息按发送顺序抵达接收方的上层应用，需要用\**消息序号**来标记消息的发送先后顺序的。**TCP**是「**双工**」(Duplex)连接，同时支持双向通信，也就是双方同时可向对方发送消息，其中 **SYN** 和 **SYN-ACK** 消息开启了 A→B 的单向通信通道（B 获知了 A 的消息序号）；**SYN-ACK** 和 **ACK** 消息开启了 B→A 单向通信通道（A 获知了 B 的消息序号）。但实际上，网络可能不稳定会丢包，使握手消息不能抵达对方，也可能是对方故意不按规矩来，故意延迟或不发送握手确认消息。当 B 面临海量的连接 A 时，SYN Flood** 攻击就形成了。

![image-20240303123740064](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240303123740064.png)

**2.SYN Flood的常见形式？**

- **直接攻击：** 不伪造 IP 地址的 SYN 洪水攻击称为直接攻击。在此类攻击中，攻击者完全不屏蔽其 IP 地址。由于攻击者使用具有真实 IP 地址的单一源设备发起攻击，因此很容易发现并清理攻击者。为使目标机器呈现半开状态，黑客将阻止个人机器对服务器的 SYN-ACK 数据包做出响应。为此，通常采用以下两种方式实现：部署防火墙规则，阻止除 SYN 数据包以外的各类传出数据包；或者，对传入的所有 SYN-ACK 数据包进行过滤，防止其到达恶意用户机器。实际上，这种方法很少使用（即便使用过也不多见），因为此类攻击相当容易缓解 – 只需阻止每个恶意系统的 IP 地址。哪怕攻击者使用僵尸网络（如 [Mirai 僵尸网络open in new window](https://www.cloudflare.com/learning/ddos/glossary/mirai-botnet/)），通常也不会刻意屏蔽受感染设备的 IP。
- **欺骗攻击：** 恶意用户还可以伪造其发送的各个 SYN 数据包的 IP 地址，以便阻止缓解措施并加大身份暴露难度。虽然数据包可能经过伪装，但还是可以通过这些数据包追根溯源。此类检测工作很难开展，但并非不可实现；特别是，如果 Internet 服务提供商 (ISP) 愿意提供帮助，则更容易实现。
- **分布式攻击（DDoS）：** 如果使用僵尸网络发起攻击，则追溯攻击源头的可能性很低。随着混淆级别的攀升，攻击者可能还会命令每台分布式设备伪造其发送数据包的 IP 地址。哪怕攻击者使用僵尸网络（如 Mirai 僵尸网络），通常也不会刻意屏蔽受感染设备的 IP

**3.如何缓解SYN Flood**

- 扩展积压工作队列：增加操作系统允许的最大半开连接数目，系统必须额外预留内存资源以处理各类新请求。
- 回收最先创建的TCP半开连接：填充积压工作后覆盖最先创建的半开连接，要求完全建立合法连接的时间
- SYN Cookie:此策略要求服务器创建 Cookie。为避免在填充积压工作时断开连接，服务器使用 SYN-ACK 数据包响应每一项连接请求，而后从积压工作中删除 SYN 请求，同时从内存中删除请求，保证端口保持打开状态并做好重新建立连接的准备。如果连接是合法请求并且已将最后一个 ACK 数据包从客户端机器发回服务器，服务器将重建（存在一些限制）SYN 积压工作队列条目。虽然这项缓解措施势必会丢失一些 TCP 连接信息，但好过因此导致对合法用户发起拒绝服务攻击。

#### 3.UDP Flood(洪水)

UDP Flood也是一种拒绝服务攻击，将大量的用户数据报协议（UDP）数据包发送到目标服务器，目的是压到该设备的处理和响应能力。防火墙保护目标服务器也可能因UDP泛滥而耗尽，从而导致对合法流量的拒绝服务。

**1.UDP Flood攻击原理：**

**UDP Flood** 主要通过利用服务器响应发送到其中一个端口的 **UDP** 数据包所采取的步骤。在正常情况下，当服务器在特定端口接收到 **UDP** 数据包时，会经过两个步骤：

- 服务器首先检查是否正在运行正在侦听指定端口的请求的程序。

- 如果没有程序在该端口接收数据包，则服务器使用 **ICMP**（ping）数据包进行响应，以通知发送方目的地不可达。

  服务器接收到每个新的 **UDP** 数据包时，它将通过步骤来处理请求，并利用该过程中的服务器资源。发送 **UDP** 报文时，每个报文将包含源设备的 **IP** 地址。在这种类型的 **DDoS** 攻击期间，攻击者通常不会使用自己的真实 **IP** 地址，而是会欺骗 **UDP** 数据包的源 **IP** 地址，从而阻止攻击者的真实位置被暴露并潜在地饱和来自目标的响应数据包服务器。

  由于目标服务器利用资源检查并响应每个接收到的 **UDP** 数据包的结果，当接收到大量 **UDP** 数据包时，目标的资源可能会迅速耗尽，导致对正常流量的拒绝服务。

  ![image-20240303184059796](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240303184059796.png)

**2.缓解UDP Flooding：**

大多数操作系统部分限制了 **ICMP** 报文的响应速率，以中断需要 ICMP 响应的 **DDoS** 攻击。这种缓解的一个缺点是在攻击过程中，合法的数据包也可能被过滤。如果 **UDP Flood** 的容量足够高以使目标服务器的防火墙的状态表饱和，则在服务器级别发生的任何缓解都将不足以应对目标设备上游的瓶颈。

#### 4.HTTP Flood(洪水)

HTTP Flood 是一种大规模的DDOS（Distributed Denial of service，分布式拒绝服务)攻击，旨在利用HTTP请求使目标服务器不堪重负。目标因请求而达到饱和，且无法响应正常流量后，将出现拒绝服务，拒绝来自实际用户的其他请求。

![image-20240303184415559](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240303184415559.png)

**1.HTTP Flood的攻击原理：**

HTTP 洪水攻击是“第 7 层”DDoS 攻击的一种。第 7 层是 OSI 模型的应用程序层，指的是 HTTP 等互联网协议。HTTP 是基于浏览器的互联网请求的基础，通常用于加载网页或通过互联网发送表单内容。缓解应用程序层攻击特别复杂，因为恶意流量和正常流量很难区分。

HTTP 洪水攻击有两种：

- **HTTP GET 攻击**：在这种攻击形式下，多台计算机或其他设备相互协调，向目标服务器发送对图像、文件或其他资产的多个请求。当目标被传入的请求和响应所淹没时，来自正常流量源的其他请求将被拒绝服务。

- **HTTP POST 攻击**：一般而言，在网站上提交表单时，服务器必须处理传入的请求并将数据推送到持久层（通常是数据库）。与发送 POST 请求所需的处理能力和带宽相比，处理表单数据和运行必要数据库命令的过程相对密集。这种攻击利用相对资源消耗的差异，直接向目标服务器发送许多 POST 请求，直到目标服务器的容量饱和并拒绝服务为止。

  **2.如何防护HTTP Flood？**

  ****一种方法是对发出请求的设备实施质询，以测试它是否是机器人，这与在线创建帐户时常用的 CAPTCHA 测试非常相似。通过提出 JavaScript 计算挑战之类的要求，可以缓解许多攻击。

  其他阻止 HTTP 洪水攻击的途径包括使用 Web 应用程序防火墙 (WAF)、管理 IP 信誉数据库以跟踪和有选择地阻止恶意流量，以及由工程师进行动态分析。Cloudflare 具有超过 2000 万个互联网设备的规模优势，能够分析来自各种来源的流量并通过快速更新的 WAF 规则和其他防护策略来缓解潜在的攻击，从而消除应用程序层 DDoS 流量。

#### 5.DNS Flood(洪水)

域名系统（DNS）服务器是互联网的“电话簿“；互联网设备通过这些服务器来查找特定 Web 服务器以便访问互联网内容。DNS Flood 攻击是一种分布式拒绝服务（DDoS）攻击，攻击者用大量流量淹没某个域的 DNS 服务器，以尝试中断该域的 DNS 解析。如果用户无法找到电话簿，就无法查找到用于调用特定资源的地址。通过中断 DNS 解析，DNS Flood 攻击将破坏网站、API 或 Web 应用程序响应合法流量的能力。很难将 DNS Flood 攻击与正常的大流量区分开来，因为这些大规模流量往往来自多个唯一地址，查询该域的真实记录，模仿合法流量。

**1.DNS Flood的攻击原理是：**

域名系统的功能是将易于记忆的名称（例如 [example.comopen in new window](http://example.com)）转换成难以记住的网站服务器地址（例如 192.168.0.1），因此成功攻击 DNS 基础设施将导致大多数人无法使用互联网。DNS Flood 攻击是一种相对较新的基于 DNS 的攻击，这种攻击是在高带宽[物联网（IoT）open in new window](https://www.cloudflare.com/learning/ddos/glossary/internet-of-things-iot/)[僵尸网络open in new window](https://www.cloudflare.com/learning/ddos/what-is-a-ddos-botnet/)（如 [Miraiopen in new window](https://www.cloudflare.com/learning/ddos/glossary/mirai-botnet/)）兴起后激增的。DNS Flood 攻击使用 IP 摄像头、DVR 盒和其他 IoT 设备的高带宽连接直接淹没主要提供商的 DNS 服务器。来自 IoT 设备的大量请求淹没 DNS 提供商的服务，阻止合法用户访问提供商的 DNS 服务器。

DNS Flood 攻击不同于 [DNS 放大攻击open in new window](https://www.cloudflare.com/zh-cn/learning/ddos/dns-amplification-ddos-attack/)。与 DNS Flood 攻击不同，DNS 放大攻击反射并放大不安全 DNS 服务器的流量，以便隐藏攻击的源头并提高攻击的有效性。DNS 放大攻击使用连接带宽较小的设备向不安全的 DNS 服务器发送无数请求。这些设备对非常大的 DNS 记录发出小型请求，但在发出请求时，攻击者伪造返回地址为目标受害者。这种放大效果让攻击者能借助有限的攻击资源来破坏较大的目标。

![image-20240303184801086](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240303184801086.png)

**2.如何防护 DNS Flood?**

DNS Flood 对传统上基于放大的攻击方法做出了改变。借助轻易获得的高带宽僵尸网络，攻击者现能针对大型组织发动攻击。除非被破坏的 IoT 设备得以更新或替换，否则抵御这些攻击的唯一方法是使用一个超大型、高度分布式的 DNS 系统，以便实时监测、吸收和阻止攻击流量。

#### 6.TCP重置攻击

在 **TCP** 重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断。正常情况下，如果客户端收发现到达的报文段对于相关连接而言是不正确的，**TCP** 就会发送一个重置报文段，从而导致 **TCP** 连接的快速拆卸。

**TCP** 重置攻击利用这一机制，通过向通信方发送伪造的重置报文段，欺骗通信双方提前关闭 TCP 连接。如果伪造的重置报文段完全逼真，接收者就会认为它有效，并关闭 **TCP** 连接，防止连接被用来进一步交换信息。服务端可以创建一个新的 **TCP** 连接来恢复通信，但仍然可能会被攻击者重置连接。万幸的是，攻击者需要一定的时间来组装和发送伪造的报文，所以一般情况下这种攻击只对长连接有杀伤力，对于短连接而言，你还没攻击呢，人家已经完成了信息交换。

从某种意义上来说，伪造 **TCP** 报文段是很容易的，因为 **TCP/IP** 都没有任何内置的方法来验证服务端的身份。有些特殊的 IP 扩展协议（例如 `IPSec`）确实可以验证身份，但并没有被广泛使用。客户端只能接收报文段，并在可能的情况下使用更高级别的协议（如 `TLS`）来验证服务端的身份。但这个方法对 **TCP** 重置包并不适用，因为 **TCP** 重置包是 **TCP** 协议本身的一部分，无法使用更高级别的协议进行验证。

#### 8.中间人攻击

攻击中间人攻击英文名叫 Man-in-the-MiddleAttack，简称「MITM 攻击」。指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方 直接对话，但事实上整个会话都被攻击者完全控制。

在安全领域有句话：**我们没有办法杜绝网络犯罪，只好想办法提高网络犯罪的成本**。为了避免双方说活不算数的情况，双方引入第三家机构，将合同原文给可信任的第三方机构，只要这个机构不监守自盗，合同就相对安全。

**如果第三方机构内部不严格或容易出现纰漏？**

虽然我们将合同原文给第三方机构了，为了防止内部人员的更改，需要采取什么措施呢

一种可行的办法是引入 **摘要算法** 。即合同和摘要一起，为了简单的理解摘要。大家可以想象这个摘要为一个函数，这个函数对原文进行了加密，会产生一个唯一的散列值，一旦原文发生一点点变化，那么这个散列值将会变化。

#### [有哪些常用的摘要算法呢？](#有哪些常用的摘要算法呢)

目前比较常用的加密算法有消息摘要算法和安全散列算法(**SHA**)。**MD5** 是将任意长度的文章转化为一个 128 位的散列值，可是在 2004 年，**MD5** 被证实了容易发生碰撞，即两篇原文产生相同的摘要。这样的话相当于直接给黑客一个后门，轻松伪造摘要。

所以在大部分的情况下都会选择 **SHA 算法** 。

**出现内鬼了怎么办？**

看似很安全的场面了，理论上来说杜绝了篡改合同的做法。主要某个员工同时具有修改合同和摘要的权利，那搞事儿就是时间的问题了，毕竟没哪个系统可以完全的杜绝员工接触敏感信息，除非敏感信息都不存在。所以能不能考虑将合同和摘要分开存储呢

**那如何确保员工不会修改合同呢？**

这确实蛮难的，不过办法总比困难多。我们将合同放在双方手中，摘要放在第三方机构，篡改难度进一步加大

**那么员工万一和某个用户串通好了呢？**

看来放在第三方的机构还是不好使，同样存在不小风险。所以还需要寻找新的方案，这就出现了 **数字签名和证书**。

**常见的加密算法：**

- DES:DES 使用的密钥表面上是 64 位的，然而只有其中的 56 位被实际用于算法，其余 8 位可以被用于奇偶校验，并在算法中被丢弃。因此，**DES** 的有效密钥长度为 56 位，通常称 **DES** 的密钥长度为 56 位。假设秘钥为 56 位，采用暴力破 Jie 的方式，其秘钥个数为 2 的 56 次方，那么每纳秒执行一次解密所需要的时间差不多 1 年的样子。当然，没人这么干。**DES** 现在已经不是一种安全的加密方法，主要因为它使用的 56 位密钥过短。
- IDEA：国际数据加密算法(International Data Encryption Algorithm)。秘钥长度 128 位，优点没有专利的限制。
- AES：当 DES 被破解以后，没过多久推出了 **AES** 算法，提供了三种长度供选择，128 位、192 位和 256，为了保证性能不受太大的影响，选择 128 即可。
- SM1 /SM4：之前几种都是国外的，我们国内自行研究了国密 **SM1**和 **SM4**。其中 S 都属于国家标准，算法公开。优点就是国家的大力支持和认可

![image-20240303185240255](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240303185240255.png)

常见的非对称加密算法：

- RSA（RSA 加密算法，RSA Algorithm）：优势是性能比较快，如果想要较高的加密难度，需要很长的秘钥。
- ECC：基于椭圆曲线提出。是目前加密强度最高的非对称加密算法
- SM2：同样基于椭圆曲线问题设计。最大优势就是国家认可和大力支持

![image-20240303185314335](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240303185314335.png)

**常见的散列算法：**

**MD5**：MD5 可以用来生成一个 128 位的消息摘要，它是目前应用比较普遍的散列算法，具体的应用场景你可以自行  参阅。虽然，因为算法的缺陷，它的唯一性已经被破解了，但是大部分场景下，这并不会构成安全问题。但是，如果不是长度受限（32 个字符），我还是不推荐你继续使用 **MD5** 的。

**SHA**：安全散列算法。**SHA** 分为 **SHA1** 和 **SH2** 两个版本。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。

**SM3**：国密算法**SM3**。加密强度和 SHA-256 想不多。主要是收到国家的支持。

![image-20240303185407334](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240303185407334.png)

#### 9.DDOS

DDos 全名 Distributed Denial of Service，翻译成中文就是**分布式拒绝服务**。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用**欺骗和伪装**的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。

### [如何应对 DDoS 攻击？](#如何应对-ddos-攻击)

#### [高防服务器](#高防服务器)

还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。

高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~

#### [黑名单](#黑名单)

面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。

#### [DDoS 清洗](#ddos-清洗)

**DDos** 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。

**DDoS** 清洗会对用户请求数据进行实时监控，及时发现 **DOS** 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。

#### [CDN 加速](#cdn-加速)

CDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。

在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 **DDoS** 攻击，也可以将流量分散到各个节点中，防止源站崩溃。