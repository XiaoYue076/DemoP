# java基础

### 1.java语言的三大特性：

继承：一个类继承另一个类，继承后子类拥有了父类的属性和方法【除了父类的私有属性和构造器方法】另外，子类也可以写自己特有的属性和方法，实现功能的扩展。

​         star:实现代码的复用。

封装：【信息隐蔽】把属于同一类事物的共性（属性和方法）都封装在一个类里，以方便使用。

​           star:1)实现了专业的分工。 2）隐藏信息，实现细节。

多态：相同的事物，调用相同的方法和参数时，表现出的不同状态。【基于封装和继承的基础上实现】

​           star：1）提供代码的维护性。  2）提供代码的扩展性。

### 2.java语言的主要特性：

1）简单易学2）面向对象  

3）分布式 ：支持Internet应用的开发，包括：URL、URLConnection、Socket

4）支持多线程  ：线程必须由Thread或子类来创建

5）健壮性  ：强类型机制、异常处理、垃圾自动收集 【对指针的 丢弃】

6）跨平台：与java虚拟机相关，一次编译，到处运行。

### 3.jdk和jre的区别

**JDK** java Development Kit(java开发工具包) 是整个java的核心，包括JRE和一堆开发工具（javac\javap)

**JRE** java Runtime Enviroment(java运行时环境)即java运行平台，包括JVM和java核心类库和支持文件

### 4.java基本类型和封装类型

![image-20240227175733660](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240227175733660.png)

为什么需要封装类？

因为泛型类包括了预定义的集合，使用的参数都是对象类型，无法直接使用基本数据类型，所以java提供了这些基本类的封装类。

基本类型与封装类的区别：

- 基本类型只能按值传递，封装类按引用传递。
- 基本类型在栈中创建，效率高，但有内存泄漏的问题，对象类型在堆中创建，对象的引用在栈中创建。

类型转换：

- 强制类型转换 容量大的类型向容量小的类型转换时使用
- 隐式类型转换  容量小的类型向容量大的类型转换时使用

### 5.==与equals的区别

==比较两个对象的引用，即在内存里存储的位置是否一致。基本数据类型和string常量可直接比较。

equals 比较的内容是否是一样的。

### 6.while循环和do循环的区别

while结构在循环开始的时候判断是否继续下一次迭代。

do/while 在循环结尾的时候判断，此时 至少执行一次循环体。

### 7.&和&&的区别

& 按位与，逻辑与 ：二者相同则为1，不同则为0

&&短路与：当一方为false时，则不在判断另一方。（判断某对象中的属性是否等于某值时，必须用&&，否则会出现空指针问题。）

空指针问题：常指的是在编程过程中出现的空指针异常（Null Pointer  Exception），这是一种常见的编程错误。当程序试图使用一个空（null）引用的对象时，而这个对象实际上不存在，就可能发生空指针异常。空指针是指向内存中的一个位置，但该位置没有任何有效的数据或者对象，因此它不能用于访问对象的成员变量或函数。在Java语言中，空指针的特殊值被定义为`NULL`。总结起来，空指针问题意味着程序员在代码中使用了一个无效的对象引用

### 8.final、finally、finalize的区别与用法

**final:关键字和修饰符**

- 一个基本数据类型的final变量，其数值一旦初始化后便不能更改。一个引用型的变量，在对其初始化后不能再指向另一个对象，但所指对象的内容可以改变。
- 被final修饰的类无法被继承，被其修饰的方法不能重写，但可以重载。
- 不能修饰抽象类，因为定义抽象类就是让其他继承的。
- 注意：类的private方法会隐式地被指定为final方法。

**finally:关键字**

- 在进行异常处理时，用来执行任何清楚操作。无论异常是否被抛出和捕获。finally块都会执行。
- 极端情况下：对于try块没执行，其也不执行；若try块中jvm关机，如exit(n)，则也不执行。
- finally中的return语句会覆盖try和catch中的，因此不建议finally块中有return语句。

**finalize: 是Object类的protected方法，子类可以覆盖该方法实现资源清理，在GC回收前被调用。**

finalize()方法存在很多问题：

- java语言规范不保证finalize会被及时执行，也不保证一定执行。
- 会带来性能问题，因为JVM通常在单独的低优先级线程中完成finalize的执行。
- 最多由GC执行一次，蛋壳手动调用对象的finalize方法。

GC：（garbage [collection](https://so.csdn.net/so/search?q=collection&spm=1001.2101.3001.7020)，内存自动回收）当一个对象不能再被后续程序所引用到时,这个对象所占用的内存空间就没有存在的意义了,java虚拟机会不定时的去检测内存中这样的对象,然后回收这块内存空间

### 9.hashCode()和equals()的区别

equals()相等的两个对象，他们的hashCode()一定相等，即用equals()对比绝对可靠。

hashCode()相等的两个对象，equals（）不一定相等。

原因：按照hashCode来访问小内存块，所以hashCode必须相等，hashmap获取一个对象是比较key的HashCode相等和equals为true。ex:Object A和Object B 他们都有属性name，hashcode以name计算，所以hashcode一样，但是两个对象属于不同类型，所以equals为false.

### 10.public、private、protected的区别，继承方法与权限

![image-20240227194430761](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240227194430761.png)

### 11.为什么java里没有全局变量

**Java中没有全局变量**,但可以通过public static成员变量来模拟全局变量

因为全局变量是全局可见的，全局变量会破坏引用透明性原则，导致了命名空间的冲突。

### 12.重载（Overload)和重写（override)的区别

二者都是实现多态的方式，不能根据返回类型进行区分

**重载：**

- 实现编译时的多态
- 发生在一个类中，同名方法的参数列表不同（参数类型，参数个数）

**重写：**

- 运行时的多态
- 发生在子类与父类，子类被重写方法要与父类被重写方法有相同参数列表和兼容的返回类型

### 13.java的四种引用

1.强引用：ex:String s = "abc",变量s就是字符串“abc"的强引用，只要强引用存在，则GC就不回收

2.软引用：描述还有用但非必须得对象，内存足不回收，反之回收。{内存敏感的高速缓存}

3.弱引用：和软引用大致相同，具有更短的生命周期，一旦发现，不论内存就会回收。

4.虚引用：形同虚设，不决定生命周期，主要用来跟踪对象被GC回收的活动。【必须与引用队列联合】

### 14.Comparator与Comparable的区别

Comparator（比较器）：通常用于定义用户制定的顺序，是比较接口，可以有多个。

Comparable（类似的）：用于定义用户定义对象的自然顺序，是排序接口，总是只有一个。

### 15.序列化和反序列化

序列化：将对象转换为字节序列的过程

反序列化：将字节序列转换为目标对象的过程。

当java对象需要再网络上**传输**或者**持久化存储**到文件中时，就需要序列化。

序列化的实现：让类实现Serializable接口，标注该类对象是可被序列化的。

若不想被序列化，就在字段前加transient关键字。ex:transient private String app;//不参与序列化

### 16.java泛型和类型擦除

泛型：即参数化类型，在创建集合时，指定集合元素的类型，此集合只能传入该类型相同的参数

类型擦除：java编译器生成的字节码不包含泛型的信息，因此编译时擦除

​         方法：1）泛型用最顶级父类替换  2)移除

### 17.String str="a"与String str = new String("a")一样吗？

不一样，内存的分配方式不一样。前者分配在常量池中，后者在堆内存。

### 18.关键字static

1.抽象方法不可以是静态的，因为抽象方法将来要被重写

2.不能从一个静态（static）方法内部对非静态方法调用。静态方法只能访问静态成员，非静态方法的调用要先创建对象。

3.static不能用来修饰局部变量

4.java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，static是编译时静态绑定的。

5.**[内部类\*\*](https://www.baidu.com/s?rsv_idx=1&wd=内部类&fenlei=256&usm=1&ie=utf-8&rsv_pq=dfd13c78001cfbaf&oq=内部类和静态内部类的区别&rsv_t=3cafOSLtbb9DDSmIMU%2BVtk4cwgFk38AlKG9QlKow9NIsi9qMvx23cMXSSV0&sa=re_dqa_zy&icon=1)和[静态内部类\*\*](https://www.baidu.com/s?rsv_idx=1&wd=静态内部类&fenlei=256&usm=1&ie=utf-8&rsv_pq=dfd13c78001cfbaf&oq=内部类和静态内部类的区别&rsv_t=3cafOSLtbb9DDSmIMU%2BVtk4cwgFk38AlKG9QlKow9NIsi9qMvx23cMXSSV0&sa=re_dqa_zy&icon=1)的主要区别在于它们的作用域、访问权限和实例化方式。**

1. 作用域： 静态内部类是一个独立的类，可以在外部类的静态方法中直接访问，也可以通过外部类的实例对象访问。静态内部类的实例化不依赖于外部类的实例，可以直接通过类名来实例化。1

- 内部类是一个嵌套在外部类中的类，它可以访问外部类的所有成员，包括私有成员。内部类的实例化必须依赖于外部类的实例，需要通过外部类的实例对象来实例化。

1. 访问权限：
   - 静态内部类可以拥有自己的访问修饰符，可以是public、protected、default或private。它的访问权限不受外部类的限制，可以在外部类的任何地方被访问。
   - 内部类可以拥有自己的访问修饰符，可以是public、protected、default或private。它的访问权限受到外部类的限制，只能在外部类内部被访问。
2. 实例化方式：
   - 静态内部类的实例化不依赖于外部类的实例，可以直接通过类名来实例化。
   - 内部类的实例化必须依赖于外部类的实例，需要通过外部类的实例对象来实例化。

静态内部类可以有静态成员（方法，属性），而非静态内部类则不能有静态成员（方法，属性）。静态内部类只能够访问外部类的静态成员，而非静态内部类则可以访问外部类的所有成员（方法，属性）

### 19.解释java中 public static void main(String[] args)中的关键字

1. `public`（公共）：表示该方法可以被其他类访问。这意味着main()方法可以从任何地方调用，包括同一个类、不同的类或者外部程序。
2. `static`（静态）：表示该方法属于类而非对象。因此，我们无需创建类的实例就能直接通过类名来调用main()方法。
3. `void`（空）：表示main()方法没有返回值。也就是说，当运行到main()方法时，程序将会开始执行并结束后立即退出。
4. `main`（主要）：指定了该方法为程序的入口点。所有的Java应用程序都必须包含一个public static void main(String[])方法。
5. `(String[] args)`：参数列表，args是命令行传递给程序的参数。在控制台上输入的内容将存储在args数组中供程序使用。

### 20.注释的分类及作用

- 单行注释 ：单行代码添加描述的时候用
- 多行注释：多行代码添加多行注释的时候用
- 文档注释：生产java帮助文档的时候使用，开发中用来描述类、方法

### 21.聊聊jdk1.8的新特性

- Lambda表达式
- 引入了接口的静态实现和默认实现
- 函数式接口
- 新的日期类LocalDate
- 引入了stream类，支持链式编程

### 22.说说内存泄漏和内存溢出

内存溢出：（out of memory）通俗理解就是内存不够，指程序要求的内存超出了系统所能分配的范围，通常在运行大型软件或游戏时，软件或游戏所需要的内存远远超出了你主机内安装的内存所承受大小，就叫内存溢出。比如申请一个int类型，但给了它一个int才能存放的数，就会出现内存溢出，或者是创建一个大的对象，而堆内存放不下这个对象，这也是内存溢出。

内存泄漏：（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

因此，我们从上面也可以推断出内存泄露可能会导致内存溢出。

二者的关系：

    内存溢出会抛出异常，内存泄露不会抛出异常，大多数时候程序看起来是正常运行的
### 23.Error和Exception的区别

![image-20240227204432229](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240227204432229.png)

Error 和 Exception 都是Throwable的子类, 在java中只有Throwable类型的实例才可以被抛出或者捕获,它是异常处理机制的基本类型.

1,Exception 和 Error体现了java平台设计者对不同异常情况的分类, Exception是程序正常运行中,可以预料的意外情况,可以被捕获,进行相应的处理.
2.Error 是指正常情况下,不大可能出现的情况,绝大部分的Error 都会导致程序处于非正常的,不可恢复的状态, 不需要捕获, 常见的OutOfMemoryError 是Error的子类.
3.Exception 分为可检查异常(checked) 和 不可检查异常(unchecked).可检查异常在源代码里必须显式的进行捕获处理,这是编译期检查的一部分,不可检查异常是指运行时异常, 比如NullPointerException, ArrayIndexOutOfBoundsException之类, 通常是可以编码避免的逻辑错误,具体根据需要来判断是否需要捕获,并不会在编译期强制要求.

### 24.常见的Exception

常见的异常

|---java.lang.Throwable:异常体系的根父类

   |---java.lang.Error:错误。Java虚拟机无法解决的严重问题。如JVM系统内部错误、资源耗尽等    严重情况，一般不编写针对性的代码进行处理。

        |---StackOverflowError（深递归导致栈被耗尽而抛出的异常）
    
        |---OutOfMemoryError（内存溢出异常）

   |---java.lang.Exception:异常。可编写针对性代码进行处理

        |---编译时异常，（受检异常）在执行javac.exe命令时，出现的异常
    
                        |---ClassNotFoundException 没有找到类
    
                         |---FileNotFoundException  没有找到文件
    
                         |---IOException  IO异常      
    
        |---运行时异常，（非受检异常）在执行java.exe命令时，出现的异常
    
                         |---ArraylndexOutOfBoundException 数组索引越界
    
                         |---NullPointerException 空指针异常
    
                         |---ClassCastException  类型转换异常
    
                         |---NumberFormatException 数字转换异常
    
                         |---ArithmeticException 算数错误异常
    
                         |---IllegalArgumentException 使用非法实参调用方法
### 25.throw和throws的区别

##### throws声明异常：

用来声明一个方法可能抛出的所有异常信息，表示出现异常的一种可能性，但并不一定会发生这些异常

常在一个方法（类）的声明处通过 throws 声明方法（类）可能拋出的异常信息

throws 通常不用显式地捕获异常，可由系统自动将所有捕获的异常信息抛给上级方法

##### throw抛出异常：

是指拋出的一个具体的异常类型，执行 throw 则一定抛出了某种异常对象

在方法（类）内部通过 throw 声明一个具体的异常信息

throw 则需要用户自己捕获相关的异常，而后再对其进行相关包装，最后将包装后的异常信息抛出

### 26.处理异常的关键字

(1). throw：有时我们显式地想要创建一个异常对象，然后抛出它来停止程序的正常处理。throw关键字用于向运行时抛出异常来处理它。
(2). throws：当我们在一个方法中抛出任何选中的异常而不处理它时，我们需要在方法签名中使用throws关键字来让调用程序知道该方法可能抛出的异常。调用者方法可以处理这些异常，或者使用throws关键字将它们传播到调用者方法。我们可以在throws子句中提供多个异常，它也可以与main（）方法一起使用。
(3). try-catch：我们在代码中使用try-catch块来处理异常。try是块的开始，catch在try块的末尾处理异常。我们可以用try来创建多个catch块，也可以嵌套try catch块。catch块需要类型为Exception的参数。
(4). finally:finally块是可选的，只能与try-catch块一起使用。由于异常会停止执行过程，因此我们可能会打开一些资源，而这些资源不会关闭，因此我们可以使用finally块。无论是否发生异常，finally块始终执行。