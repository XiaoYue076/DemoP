# JUC并发编程

### 1.实现多线程的几种方法？

- 继承Thread类
- 实现Runnable接口
- 实现Callable接口
- 线程池方式创建

采用继承Thread类的优缺点：

- 优点：编写 简单，若需要访问当前线程，直接使用this即可获取当前线程。
- 缺点：java是单继承的，无法再继承其他父类。

采用实现Runnable接口、Callable接口的优缺点：

- 优点：线程只是实现了接口，还可以继承其他类，多个线程可以共享一个target对象，非常适合多个相同线程来处理同一份资源的情况，可将CPU、代码和数据分开，形成清晰的模型。
- 缺点：编程复杂，访问当前线程，必须使用Thread.currentThread()方法。

### 2.如何停止一个正在运行的线程

1. 使用退出标志，使线程正常退出，当run方法完成后线程终止。
2. 使用stop方法强行终止。（不推荐，因为stop、suspend、resume都是过期作废的方法）
3. 使用interrupt方法中断线程。

### 3.notify（）和notifyAll()的区别

notify可能会导致死锁，而notifyAll不会。使用notifyAll可以唤醒所有处于wait状态的线程，使其重写加入锁的争夺队列中，而notify只能唤醒一个。

notify是对notifyAll的一个优化，但是它有很精确的应用场景，并且要求正确使用，不然会导致死锁。正确的场景是WaitSet中等待的是相同的条件，唤醒任一个都能正确处理接下来的事项，如果唤醒的线程无法正确处理，务必确保继续notify下一个线程，并且自身需要重新回到WaitSet中。

#### 4.sleep和wait有什么区别？

sleep方法属于Thread类，wait方法属于Object类。

sleep方法导致了程序暂停执行指定时间，让出CPU该其他线程，但是监控状态依然保持着，当指定的时间到了又会恢复运行状态。在调用sleep方法的过程中，线程不会释放对象锁。

当调用wait方法的时候，线程会释放对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify方法后才进入对象锁定池准备，获取对象锁进入运行状态。

**总结：**共同点：两者都可以暂停线程的执行

区别：

- sleep()方法没有释放锁，而Wait()方法释放了锁。
- wait()通常被用于线程间交互与通信，sleep()通常被用于暂停执行。
- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行后会自动苏醒，或者也可以使用wait（long timeout)超时后线程会自动苏醒。
- sleep()是Thread类的静态本地方法，wait()是Object的本类方法。

### Synchronized是什么？

synchronized是java中的一个关键字，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

可以修饰实例方法（锁当前实例）、静态方法（锁当前类）、代码块（锁指定对象/类）尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能。

【构造方法不能使用synchronized修饰，因为其本身就属于线程安全的，不存在同步的构造方法】

`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。

**不过两者的本质都是对对象监视器 monitor 的获取。**

### 5.Volatile是什么？

*原子性：只能保证单一变量的原子性，不能保证复合操作的原子性。*

可见性：volatile修饰的变量只要被修改，其他线程能感知到。

**volatile关键字除了可以保证变量的可见性，还有一个重要的作用就是防止JVM的指令重排序**。将变量声明为volatile，在对这个变量进行读写操作的时候，会通过插入特定的内存屏障的方式来禁止指令重排序。

**Synchronized关键字和Volatile关键字是互补的存在**：

- volatile是线程同步的轻量级实现，性能更好，但是它只能用于变量而Synchronized可以修饰方法和代码块。
- volatile只能保证数据的可见性，Synchronized可见性和原子性都可以。
- volatile主要用于解决变量在多个线程之间的可见性，Synchronized解决的是多个线程之间访问资源的同步性。

### 6.start和run方法的区别？

start方法被用来启动新创建的线程，而start内部调用了run方法，这和直接调用run方法不一样。当调用run方法的时候，只会在原来的线程中调用，没有新的线程启动。

### 7.为什么wait、notify、notifyAll方法不在thread类里？

java提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。而wait、notify、notifyAll都是锁级别的操作，所以定义在Object类中，因为锁属于对象。

### 8.为什么wait和notify方法要在同步块中调用

- 只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait、notify、notifyAll的方法。
- 如果不这么做，会抛出IllegalMonitorStateException异常。
- 避免wait和notify之间产生竞态条件。

wait方法强制当前线程释放对象锁。这意味着在调用某对象的wait方法前，当前线程必须已经获得该对象的锁。因此线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait方法。

调用wait方法通常是，调用线程希望某个特殊的状态被设置之后再执行。调用notify方法通常是，调用线程希望告诉其他等待中的线程：“特殊状态已经被设置”，这个状态作为线程间通信的通道，它必须是一个可变的共享状态。

### 9.interrupted和isInterruptedd方法的区别？

主要区别是前者会将中断状态清除而后者不会。java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted用来查询其他线程的中断状态且不会改变中断标识。

### 10.synchronized和ReentrantLock有什么不同？

**相同点**：二者都是加锁方式同步，并且都是阻塞式同步（可重入锁）。即如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的。

**区别**：synchronized是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock是jdk1.5之后提供的API层面的互斥锁，需要lock（）和unlock()方法配合try、finally语句块来实现。

synchronized经过编译，会在同步块的前后分别形成monitorenter和monitoreExit这两个字节码指令。在执行前者指令时首先要尝试获取对象锁。如果这个锁没有被锁定，或者当前线程已经有了对象锁，就把锁的计算器加1，相应的执行后者时，将计算器减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。

ReentrantLock是java.util.concurrent包下提供的一套互斥锁，有以下高级功能：

1.等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于synchronized来说可以避免死锁。

2.公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不好。

3.锁绑定多个条件，RenntrantLock对象可以同时绑定多个对象。

### 11.java线程和操作系统的线程有啥区别？

- 用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）
- 内核线程：由操作系统的内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）

用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。【现在的java线程的本质就是操作系统的线程】

常见的线程模型有这三种：

1. 一对一（一个用户线程对应一个内核线程）
2. 多对一（多个用户线程映射到一个内核线程）
3. 多对多（多个用户线程映射到多个内核线程）

### 12.描述线程与进程的关系，区别及优缺点？

在JVM中，一个进程中可以有多个线程，多个线程共享进程的堆和方法区（JDK1.8之后的元空间）资源，但是每个线程都有自己的程序计数器、虚拟机栈和本地方法栈。

**重：**

1.程序计数器（用于记录当前线程的执行位置）私有主要是为了线程切换后能恢复到正确的执行位置。

2.虚拟机栈和本地方法栈私有是为了保证线程中的局部变量不被别的线程访问到。

- **虚拟机栈**：每个java方法在执行前会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在java虚拟机中入栈和出栈的过程。
- **本地方法栈**：与虚拟机栈相似。区别是：虚拟机栈执行java方法，本地方法栈执行Native方法。

3.堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象（几乎所有对象都在这里分配内存），方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据。

**总结：线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；进程相反。**

### 12.并发与并行，同步和异步

并发：两个及两个以上的作业在**同一时间段**内执行

并行：两个及两个以上的作业在**同一时刻**执行

同步：发出一个调用之后，在没有得到结果之前，**该调用就不可以返回**，一直等待。

异步：调用在发出之后，不用等待返回结果，**该调用直接返回**。

### 13.为什么要使用多线程？

- **计算机底层**：线程可以是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
- **当代互联网发展趋势**：多线程并发编程时开发高并发系统的基础，利用多线程机制可以大大提高系统整体的并发能力以及性能。
- **单核时代：**多线程为了提高单进程利用CPU和IO系统的效率。
- **多核时代：**多线程主要是为了提高进程利用多核CPU的能力。

多线程可能带来的问题：并发编程的目的是为了能提高程序的执行效率进而提高程序的运行速度，但是会遇到内存泄漏、死锁、线程不安全等问题。

### 14.如何理解线程安全和不安全？

线程安全与否是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。

- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能够保证这份数据的正确性和一致性。
- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

### 15.单核CPU运行多个线程效率一定高吗？

两种类型的线程：

- **CPU密集型：**主要进行计算和逻辑处理，需要占用大量的CPU资源
- **IO密集型：**主要进行输入输出操作，如读写文件、网络通信等，需要等待IO设备的响应，而不用占用太多的CPU资源。

在单核CPU上，同一时刻只能有一个线程在运行，其他线程需要等待CPU的时间片分配。若是CPU密集型，多个线程同时运行会导致频繁的线程切换，增加了系统开销，降低效率；若是IO密集型，多个线程同时运行可以利用CPU在等待IO时的空闲时间，提高效率。

### 16.线程的生命周期和状态

- **new：**初始状态，线程被创建出来但没有被调用start()
- **runnable:**运行状态，线程被调用了start（）等待运行的状态
- **Blocked:**阻塞状态，需要等待锁释放
- **Waiting:**等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）
- **Time_waiting:**超时等待状态，可以在指定的时间后自行返回而不是像waiting那样一直等待
- **Terminated:**终止状态，表示该线程已经运行完毕

线程在生命周期中并不是固定处于某个状态而是随着代码的执行在不同的状态之间切换。

1. 当线程执行 `wait()`方法之后，线程进入 **WAITING（等待）** 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。
2. **TIMED_WAITING(超时等待)** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）`方法或 `wait（long millis）`方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。
3. 当线程进入 `synchronized` 方法/块或者调用 `wait` 后（被 `notify`）重新进入 `synchronized` 方法/块，但是锁被其它线程占有，这个时候线程就会进入 **BLOCKED（阻塞）** 状态。
4. 线程在执行完了 `run()`方法之后将会进入到 **TERMINATED（终止）** 状态

### 17.线程上下文切换

线程在执行过程中会有自己的运行条件和状态，当出现某些状况就，线程会从占用CPU状态中退出。【上下文切换是现代操作系统的基本功能，因其每次需要保存信息、恢复信息，这将会占用CPU，内存等系统资源进行处理。意味着效率会有一定损耗，频繁切换就会造成整体效率低下】

1. 主动让出CPU，比如调用sleep().wait()等。
2. 时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。
3. 调用了阻塞类型的系统中断，比如请求IO、线程被阻塞。
4. 被终止或结束运行。

前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留到线程下次占用CPU的时候恢复现场，并加载下一个将要占用CPU的线程上下文。

### 18.线程死锁及避免死锁

产生死锁的四个必要条件：

- **互斥条件：**该资源任意一个时刻只由一个线程占用
- **请求与保持条件：**一个线程因请求资源而被阻塞时，对已获得的资源保持不放。
- **不剥夺条件：**线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- **循环等待条件：**若干线程之间形成一种头尾相接的循环等待资源关系。

预防死锁：

1. **破坏请求与保持：**一次性申请所有的资源
2. **破坏不剥夺条件：**占用部分资源的线程进一步申请其他资源时，如何申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件：**按顺序申请资源，释放则反序释放。

避免死锁：【银行家算法】

### 19.可以直接调用Thread类的run方法吗？

new一个Thread，线程进入了新建状态。调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作。但是直接执行run方法，会把run()方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这不是多线程工作。

**调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**

### 20.乐观锁和悲观锁

**悲观锁**：总是假设最坏的情况，认为共享资源每次被访问的时候会出现问题（比如共享数据被修改），所以**每次在获取资源操作的时候都会上锁**，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。【共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程】

ex:Synchronized和ReentrantLock等独占锁。

**乐观锁：**总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，**无需加锁也无需等待**，只是在提交修改的时候验证对应的资源是否被其他线程修改了。

ex:java.util.concurrent.atomic包下面的原子变量类（AtomicInteger、LongAdder）就是使用了乐观锁的一种实现方式实现CAS。

使用场景：

- 悲观锁：通常用于写比较多的情况，这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。
- 乐观锁：通常用于写比较少的情况，这样可以避免频繁加锁影响性能，主要针对的对象是单个共享变量。

###   21.CAS和AQS

**CAS全程Compare And Swap(比较与交换)**，用于实现乐观锁，原理就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。

CAS的问题：ABA问题（无法确定值是否被修改过）、循环时间长开销大、只能保证一个共享变量的原子操作。

**AQS全程AbstractQueuedSynchronizer**（队列同步器），是一个抽象类，主要用于构建锁和同步器，在java.util.concurrent.locks包下。

![img](https://oss.javaguide.cn/github/javaguide/java/CLH.png)

**原理**：AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 **CLH 队列锁** 实现的，即将暂时获取不到锁的线程加入到队列中。

【CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）】

### 22.公平锁和非公平锁，可中断锁和不可中断锁

**公平锁：**锁被释放之后，先申请的线程先得到锁。性能较差，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。

**非公平锁：**锁被释放之后，后申请的线程可能先获取锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁。

**可中断锁：**获取锁的过程中可以被中断，不需要一直等到获取锁之后才能进行其他逻辑处理。ReentrantLock就属于可中断锁。

**不可中断锁：**一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。Synchronized就是不可中断锁。

**共享锁:**一把锁可以被多个线程同时获得

**独占锁：**一把锁只能被一个线程获得

### 23.线程持有读锁还能获取写锁吗？

- 在持有读锁的情况下，该线程不能获取写锁（因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有）
- 在持有写锁的情况下，该线程可以继续获取读锁。
- 写锁可以降级为读锁，但是读锁不能升级为写锁。因为这样会引起线程的争夺，写锁是独占锁，会影响性能。

### 24.ThreadLocal的作用

ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。

**每个`Thread`中都具备一个`ThreadLocalMap`，而`ThreadLocalMap`可以存储以`ThreadLocal`为 key ，Object 对象为 value 的键值对。**ThreadLocalMap是ThreadLocal的静态内部类。

![ThreadLocal内部类](https://oss.javaguide.cn/github/javaguide/java/concurrent/thread-local-inner-class.png)

ThreadLocal内存泄漏问题怎么导致的？

ThreadLocalMap中使用的key为ThreadLocal的弱引用，而value是强引用。所以，如果ThreadLocal没有被外部强引用的情况下，在GC时，key会被清理掉，Value不会被清理掉。【弱引用：一旦发现，无论内存是否够用都会被回收】

### 25.线程池的好处

**线程池**：管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。

- **降低资源消耗：**通过重复利用已创建的线程降低线程常见和销毁造成的消耗
- **提高响应速度：**任务到达时，不需要等待线程创建就立即执行。
- **提高线程的可管理性：**线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

如何创建线程池：1）（推荐）通过ThreadPoolExcutor构造函数来创建 2）通过Executor 框架的工具类Executors来创建

### 1.线程池的核心参数

线程池核心参数主要参考ThreadPoolExecutor这个类的7个参数的构造函数：

- corePoolSize核心线程数目
- maximumPoolSize最大线程数目=（核心线程+救急线程的最大数目）
- keepAliveTime生存时间:救急线程的生存时间，生存时间内没有新任务，此线程资源会释放
- unit时间单位:救急线程的生存时间单位，如秒、毫秒等
- workQueue当没有空闲核心线程时，新来任务会加入到此队队列里，队列满会创建救急线程执行任务
- threadFactory线程工厂：可以定制线程对象的创建，如设置线程名字、是否守护线程等
- handler拒绝策略：当所有线程都在繁忙，workQueue也放满时，会触发拒绝策略

![image-20240321170153124](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321170153124.png)

工作流程：

1. 任务在提交的时候，首先判断核心线程数是否已满，如果没有满则直接添加到工作线程执行。
2. 如果核心线程满了，则判断阻塞队列是否已满，如果没有满，当前任务存储阻塞队列。
3. 如果阻塞队列也满了，则判断线程数是否小于最大线程数，如果满足条件，则使用临时线程执行任务。【如果核心或临时线程执行完成任务后会检查阻塞队列中是否有需要执行的线程，如果有，则使用非核心线程执行任务】
4. 如果所有线程都忙着（核心线程+临时线程）则走拒绝策略。

![image-20240321170536419](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321170536419.png)

拒绝策略：

- AbortPolicy:直接抛出异常，默认策略
- CallerRunPolicy:用调用者所在的线程来执行任务
- DiscardOldestPolicy:丢弃阻塞队列中靠前的任务，并执行当前任务
- DiscardPolicy:直接丢弃任务

### 2.线程池常见的阻塞队列

常见的有4个，最多用的是ArrayBlockingQueue和LinkedBlockingQueue

1. ArrayBlockingQueue：基于数组结构的有界阻塞队列FIFO
2. LinkedBlockingQueue：基于链表结构的有界阻塞队列FIFO
3. DelayedWorkQueue:是一个优先级队列，可以保证每次出队的任务都是当前队列中执行时间最靠前的
4. SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作

**ArrayBlockingQueue和LinkedBlockingQueue的区别：**

![image-20240321171343737](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321171343737.png)

左边是LinkedBlockingQueue加锁的方式，右边是ArrayBlockingQueue加锁的方

式

![image-20240321171414997](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321171414997.png)

- LinkedBlockingQueue读和写各有一把锁，性能相对较好
- ArrayBlockingQueue只有一把锁，读和写公用，性能相对于
- LinkedBlockingQueue差一些

### 3.如何确定核心线程数

设置核心线程数之前，需要熟悉一些执行线程池任务的类型：

- IO密集型任务：文件读写、DB读写、网络请求

  推荐：核心线程数大小设置为2N+1（N为CPU数）

- CPU密集型任务：计算型代码、Bitmap转换、Gson转换等

​       推荐：核心线程数大小设置为N+1

① 高并发、任务执行时间短 -->（ CPU核数+1 ），减少线程上下文的切换

② 并发不高、任务执行时间长

IO密集型的任务 --> (CPU核数 * 2 + 1)

计算密集型任务 --> （ CPU核数+1 ）③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整

体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器

是第二步，至于线程池的设置，设置参考（2）

### 4.线程池的种类

- 创建使用固定线程数的线程池
- 单线程化的线程池
- 可缓存线程池
- 提供了“延迟”和“周期执行”功能的ThreadPoolExecutor

**1.创建使用固定线程数的线程池**

![image-20240321171924577](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321171924577.png)

- 核心线程数与最大线程数一样，没有救急线程
- 阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE
- 场景：适用于任务量已知，相对耗时的任务

**2.单线程化的线程池，它只会用唯一的工作线程来执行任 务，保证所有任务按**

**照指定顺序(FIFO)执行**

![image-20240321172244757](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321172244757.png)

- 核心线程数和最大线程数都是1
- 阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE
- 适用场景：适用于按照顺序执行的任务

**3.可缓存线程池**

![image-20240321172347361](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321172347361.png)

- 核心线程数为0
- 最大线程数是Integer.MAX_VALUE
- 阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。
- 适用场景：适合任务数比较密集，但每个任务执行时间较短的情况

**4.提供了“延迟”和“周期执行”功能的ThreadPoolExecutor**

适用场景：有定时和延迟执行的任务

![image-20240321172509163](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321172509163.png)

### 5.为什么不建议用Executors创建线程池

![image-20240321172541815](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321172541815.png)

### 6.CountDownLatch

CountDownLatch（闭锁/倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）

- 其中构造参数用来初始化等待计数值
- await() 用来等待计数归零
- countDown() 用来让计数减一

![image-20240321193839939](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321193839939.png)

### 7.控制某个方法允许并发访问线程的数量

Semaphore [ˈsɛməˌfɔr] 信号量，是JUC包下的一个工具类，我们可以通过其限制

执行的线程数量，达到限流的效果当一个线程执行时先通过其方法进行获取许可操作，获取到许可的线程继续执行业务逻辑，当线程执行完成后进行释放许可操作，未获取达到许可的线程进行等待或者直接结束。

Semaphore两个重要的方法

lsemaphore.acquire()： 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）

lsemaphore.release()：释放一个信号量，此时信号量个数+1

### 8.谈谈对ThreadLocal的理解

ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享。

**ThreadLocal基本使用：**

- set(value) 设置值
- get() 获取值
- remove() 清除值

**实现原理：**

ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离。在ThreadLocal中有一个内部类叫做ThreadLocalMap，类似于HashMap。ThreadLocalMap中有一个属性table数组，这个是真正存储数据的位置。

**ThreadLocal内存泄漏：**

Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用

- 强引用：最为普通的引用方式，表示一个对象处于有用且必须的状态，如果一个对象具有强引用，则GC并不会回收它。即便堆中内存不足了，宁可出现OOM，也不会对其进行回收

  ![image-20240321194352303](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321194352303.png)

- 弱引用：表示一个对象处于可能有用且非必须的状态。在GC线程扫描内存区域时，一旦发现弱引用，就会回收到弱引用相关联的对象。对于弱引用的回收，无关内存区域是否足够，一旦发现则会被回收

![image-20240321194403883](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321194403883.png)

每一个Thread维护一个ThreadLocalMap，在ThreadLocalMap中的Entry对象继承了WeakReference。其中key为使用弱引用的ThreadLocal实例，value为线程变量的副本

![image-20240321194434896](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240321194434896.png)