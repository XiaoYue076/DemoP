# JVM知识点+面试题

### 1.JVM内存模型：

JDK1.7 VS JDK1.8（运行时数据区域）

![image-20240304143401533](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240304143401533.png)

![image-20240304143303776](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240304143303776.png)

线程共享：堆、方法区、直接内存（非运行时数据区的一部分）

线程私有：线程、虚拟机栈、本地方法栈、程序计数器

java虚拟机规范对于运行时数据区域的规定相当宽松。ex:堆可以是连续空间，也可以不连续；堆得大小可以固定，也可以按需扩展。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至可以不进行垃圾收集。

#### 程序计数器：

- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪。

【程序计数器是唯一一个不会出现outOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，线程的死亡而结束】

#### java虚拟机栈（简称栈）：

是IVM运行时数据区域的一个核心，除了一些Native方法调用的是本地方法栈，其他所有java方法调用都通过栈来实现。也是线程私有的，随着线程创建而创建，线程死亡而死亡。

栈由一个个栈帧组成，而每个栈帧中都拥有：**局部变量表、操作数栈、动态链接、方法返回地址。**是先进后出的数据结构，支持入栈和出栈。

- **局部变量表：**主要存放了编译期可知的各种数据类型（boolean、byte..)、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）
- **操作数栈：**主要作为方法调用的中转站，用于存放方法执行过程中产生的中间计算结果。此外临时变量也会放在其中。
- **动态链接：**主要服务一个方法需要调用其他方法的场景。class文件的常量池里保存有大量的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转换为其在内存地址中的直接引用。【动态链接的作用：为了将符号引用转换为调用方法的直接引用】

**方法返回：**java方法有两种返回方式，一种是return正常返回，一种是抛出异常。不管是哪种返回方式，都会导致栈帧被弹出。【栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算做方法结束】

- stackOverFlowError:若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前java虚拟机栈的最大深度的时候，就抛出这个错误。
- OutOfMemoryError:如果栈的内存大小可以动态扩展，如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出此异常。

#### 本地方法栈：

和虚拟机栈所发挥作用相似，区别是：**虚拟机栈为虚拟机执行java方法（也就是字节码）服务，而本地方法栈则为虚拟机栈使用到的Native方法服务。**在HotPot虚拟机中和java虚拟机栈合二为一。

也会创建栈帧，其中也有：局部变量表、操作数栈、动态链接、出口信息，也有stackOverFlowError和OutOfMemoryError的异常。

#### 堆：

java虚拟机中所管理内存最大的一块，是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

java堆事垃圾收集器管理的主要区域，也叫GC堆（Garbage Collected Heap)。

堆内存通常被分为三部分：

1. 新生代内存(Young Generation)

2. 老生代(Old Generation)

3. 永久代(Permanent Generation)

   【jdk8版本之后永久代已经被元空间取代，元空间使用的是本地内存】

   ![image-20240304151037201](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240304151037201.png)

“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累加，当累加到某个年龄时，所累加的大小超过了 Survivor 区的一半，则取这个年龄和 `MaxTenuringThreshold` 中更小的一个值，作为新的晋升年龄阈值”。

- **`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`**：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
- **`java.lang.OutOfMemoryError: Java heap space`** :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，若没有特别配置，将会使用默认值，

#### 方法区：

方法区属于是JVM运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并且解析class文件获取相关的信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的：**类信息、字段信息、方法信息、常量、静态变量、即时编译期编译后的代码缓存等数据。**

方法区和永久代及元空间的关系，就像java中接口和类的关系，类实现了接口。接口是方法区。

#### 【重】为什么将永久代替换为元空间？

1.整个永久代有一个JVM本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存限制，溢出几率比原来更小。

2.元空间里面存放的是类的元数据，这样加载多少类的元数据不由MaxPermSize控制了，而由系统的实际可用空间来控制，这样能加载更多的类。

3.在jdk8中，合并HotPot和JRockit的代码时，JRockit从来没有一个叫永久代的东西，因此合并后无序再增加。

**方法区常用参数：**

永久代：-XX:PermSize=N //方法区 (永久代) 初始大小
-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen

元空间：-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小

#### 运行时常量池：

class文件中出来有类的版本、字段、方法、接口等描述信息，还有用于存放编译期生成的各种字面量（Literal)和符号引用（Symbolic Reference)的常量池表（Constant Pool Table)

字面量是元代码中的固定值的表示法，即通过字面就能知道其值。字面量包括整数、浮点数和字符串字面量，常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。

![image-20240304152711812](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240304152711812.png)

常量池表会在类加载后存放到方法区的运行时常量池中。运行时常量池的功能类似于传统编程语言的符号表，当常量池无法再申请到内存时会抛出OutOfMemoryError错误。

#### 字符串常量池：

是JVM为了提升性能和减少内存消耗针对字符串专门开辟的一块区域，目的是为了避免字符串的重复创建。

```
// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true
```

在jdk1.7之前，字符串常量池存放在永久代。jdk1.7字符串常量池和静态变量从永久代移动到java堆中。

#### 【重】jdk1.7为什么将字符串常量池移动到堆中？

因为永久代（方法区的实现）的GC回收率太低了，只有在整堆收集（Full GC)的时候才会被执行GC。java程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够高效及时地回收字符串内存。

#### 直接内存：

直接内存是一种特殊的内存缓冲区，是通过JNI的方式在本地内存上分配的。直接内存并不是虚拟机运行时数据区鹅一部分，也不是虚拟机规范中定义的内存区域，但这部分内存也被频繁的使用，也会导致OOM错误。

JDK1.4 中新加入的 **NIO（Non-Blocking I/O，也被称为 New I/O）**，引入了一种基于**通道（Channel）\**与\**缓存区（Buffer）\**的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为\**避免了在 Java 堆和 Native 堆之间来回复制数据**。

直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

堆外内存就是把内存对象分配在堆外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。

### 2.对象的创建：

**1.类加载检查：**虚拟机遇到一条new指令时，首先将去检查这个指令的参数能否在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加兹安过。若没有，必须先执行类加载。

**2.分配内存：**通过①后，为新生对象分配内存，选择哪种分配方式由java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。ava 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

- **指针碰撞**：

  适用场合：堆内存规整（即没有内存碎片）的情况下。

  原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。

  使用该分配方式的 GC 收集器：Serial, ParNew

- **空闲列表**：

  适用场合：堆内存不规整的情况下。

  原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。

  使用该分配方式的 GC 收集器：CMS

**内存分配并发问题：必须保证线程的安全。**

- **CAS+失败重试**：CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，若冲突失败就重试，直到成功为止。【虚拟机采用CAS配上失败重试的方式保证更新操作的原子性】
- **TLAB**：为每一个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先在TLAB中分，当对象大于TLAB中的剩余内存或者其内存用尽时，采用上述CAS进行内存分配。

**3.初始化零值：**

内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在java代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

**4.设置对象头：**

初始化零值完成以后，虚拟机要对对象进行必要的设置。如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，对象头会有不同的设置方式。

**5.执行init方法：**

执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

#### 对象的内存布局：

分为3块区域：对象头、实例数据、对齐填充。

- **Hotspot 虚拟机的对象头包括两部分信息**，**第一部分用于存储对象自身的运行时数据**（哈希码、GC 分代年龄、锁状态标志等等），**另一部分是类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
- **实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。
- **对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。** 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

**对象的访问定位：由虚拟机实现而定，方式：使用句柄、直接指针。**

如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

![image-20240304160114525](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240304160114525.png)

如果使用直接指针访问，reference 中存储的直接就是对象的地址

![image-20240304160136463](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240304160136463.png)

使用**句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改**。

使用**直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销**。HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。

### 3.JVM垃圾回收【重】

#### 1.内存分配和回收原则

- 对象优先在Eden区分配

当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 `allocation1` 无法存入 Survivor 空间，所以只好通过 **分配担保机制** 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 `allocation1`，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。

- 大对象直接进入老年代（字符串、数组）

大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。

- 长期存活的对象进入老年代

Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 `-XX:TargetSurvivorRatio=percent` 来设置，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。

**空间分配担保：为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间**。

总结：

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区

#### 2、死亡对象判断方法

①引用计数法：**方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题**

- 每当有一个地方引用它，计数器就加 1；
- 当引用失效，计数器就减 1；
- 任何时候计数器为 0 的对象就是不可能再被使用的。

②可达性分析算法：通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

可以作为GC Roots的对象：

- 虚拟机栈(栈帧中的局部变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象
- JNI（Java Native Interface）引用的对象

**对象可以被回收，就代表一定会被回收吗？**

即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize` 方法。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

#### 3.引用类型总结：

- 强引用：垃圾回收器**绝不会回收它。**当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
- 弱引用：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，**一旦发现**了只具有弱引用的对象，不管当前内存空间足够与否，都**会回收它的内存**。【由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象】
- 软引用：【**常用**】如果内存空间**足够，垃圾回收器就不会回收它**，如果内存空间不足了，就会回收这些对象的内存。【软引用可用来实现内存敏感的高速缓存】
- 虚引用：形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，**在任何时候都可能被垃圾回收**。【**虚引用主要用来跟踪对象被垃圾回收的活动**】

【**重**】**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**

#### 4.如何判断一个常量是废弃常量？

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

#### 5.如何判断一个类是无用类？

类需要同时满足下面 3 个条件才能算是 **“无用的类”**：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

#### 6.垃圾收集算法：

- **标记-清除（**Mark-and-Sweep）首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。【效率低，且会产生大量不连续的内存碎片】
- **复制算法**：它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。【可用内存变小、不适合老年代】
- **标记-整理**（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。【效率不高，适合老年代】
- **分代收集算法**：当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法【**新生代采用标记-复制算法，老年代采用标记-整理算法**】

#### 7.垃圾收集器：

**并行和并发概念补充：**

- **并行（Parallel）**：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- **并发（Concurrent）**：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。

1. Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。它的 **“单线程”** 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束。【效率高、体验感不好】

2. ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。

3. Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。关注点是吞吐量（高效率的利用 CPU）

4. Serial Old收集器：**Serial 收集器的老年代版本**，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。

5. Parallel Old收集器：**Parallel Scavenge 收集器的老年代版本**。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。

6. **CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。【对CPU资源敏感、无法处理浮动垃圾、会产生大量空间碎片】

   整个过程分为四个步骤：

   - **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
   - **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
   - **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
   - **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

7. **G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**【并行与并发、分代收集、空间整合、可预测的停顿】

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。**从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器**。运作过程：**初始标记、并发标记、最终标记、筛选回收。**

### 4.类加载过程详解【重】

#### 1.类的生命周期：

类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。

![image-20240304205518763](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240304205518763.png)

#### 2.类加载过程

系统加载 Class 类型的文件主要三步：**加载->连接->初始化**。连接过程又可分为三步：**验证->准备->解析**

类加载过程的第一步，主要完成下面 3 件事情：

1. 通过全类名获取定义此类的二进制字节流。
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构。
3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口。

验证阶段主要由四个检验阶段组成：

【**验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。**】

1. 文件格式验证（Class 文件格式检查）
2. 元数据验证（字节码语义检查）
3. 字节码验证（程序语义检查）
4. 符号引用验证（类的正确性检查）

![image-20240304205839851](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240304205839851.png)

符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常，比如：

- `java.lang.IllegalAccessError`：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。

- `java.lang.NoSuchFieldError`：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。

- `java.lang.NoSuchMethodError`：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。

  **准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

  1. 这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 `static` 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
  2. 从概念上讲，类变量所使用的内存都应当在 **方法区** 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。
  3. 这里所设置的初始值"通常情况"下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。** 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

![image-20240304210022782](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240304210022782.png)

**初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。**

1. 当遇到 new、getstatic、putstatic、或invokestatic 这 4 条字节码指令时，比如 new一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。 
   - 当 jvm 执行 `new` 指令时会初始化类。即当程序创建一个类的实例对象。
   - 当 jvm 执行 `getstatic` 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。
   - 当 jvm 执行 `putstatic` 指令时会初始化类。即程序给类的静态变量赋值。
   - 当 jvm 执行 `invokestatic` 指令时会初始化类。即程序调用类的静态方法。
2. 使用 `java.lang.reflect` 包的方法对类进行反射调用时如 `Class.forname("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类。
5. `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，
    就必须先使用 `findStaticVarHandle` 来初始化要调用的类。
6. 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

**卸载类即该类的 Class 对象被 GC。**

卸载类需要满足 3 个要求:

1. 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例已被 GC

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

JDK 自带的 `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

### 5.类加载器详解【重】

- 类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。
- 每个 Java 类都有一个引用指向加载它的 `ClassLoader`。
- 数组类不是通过 `ClassLoader` 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。

【**类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）。** 字节码可以是 Java 源程序（`.java`文件）经过 `javac` 编译得来，也可以是通过工具动态生成或者通过网络下载得】

#### 1.类加载器加载规则：

JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。

对于已经加载的类会被放在 `ClassLoader` 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。

#### 2.类加载器总结【重】

JVM 中内置了三个重要的 `ClassLoader`：

1. **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
2. **`ExtensionClassLoader`(扩展类加载器)**：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
3. **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

除了 `BootstrapClassLoader` 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 `ClassLoader`抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。

每个 `ClassLoader` 可以通过`getParent()`获取其父 `ClassLoader`，如果获取到 `ClassLoader` 为`null`的话，那么该类是通过 `BootstrapClassLoader` 加载的。

**为什么 获取到 `ClassLoader` 为`null`就是 `BootstrapClassLoader` 加载的呢？** 这是因为`BootstrapClassLoader` 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。

#### 3.自定义加载类

如果我们要自定义自己的类加载器，很明显需要继承 `ClassLoader`抽象类。

`ClassLoader` 类有两个关键的方法：

- `protected Class loadClass(String name, boolean resolve)`：加载指定二进制名称的类，实现了双亲委派机制 。`name` 为类的二进制名称，`resolve` 如果为 true，在加载时调用 `resolveClass(Class<?> c)` 方法解析该类。
- `protected Class findClass(String name)`：根据类的二进制名称来查找类，默认实现是空方法。

如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass()` 方法。

#### 4.双亲委派【重】

- `ClassLoader` 类使用委托模型来搜索类和资源。
- 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
- `ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

**双亲委派模型：**

![image-20240304211338163](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240304211338163.png)

双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的。

类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。【有一条非常经典的设计原则：**组合优于继承，多用组合少用继承。**】

```
public abstract class ClassLoader {
  ...
  // 组合
  private final ClassLoader parent;
  protected ClassLoader(ClassLoader parent) {
       this(checkCreateClassLoader(), parent);
  }
  ...
}
```

#### 5.双亲委派模型的执行流程

双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 `java.lang.ClassLoader` 的 `loadClass()` 中，相关代码如下所示。

```
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        //首先，检查该类是否已经加载过
        Class c = findLoadedClass(name);
        if (c == null) {
            //如果 c 为 null，则说明该类没有被加载过
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    //当父类的加载器不为空，则通过父类的loadClass来加载该类
                    c = parent.loadClass(name, false);
                } else {
                    //当父类的加载器为空，则调用启动类加载器来加载该类
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                //非空父类的类加载器无法找到相应的类，则抛出异常
            }

            if (c == null) {
                //当父类加载器无法加载时，则调用findClass方法来加载该类
                //用户可通过覆写该方法，来自定义类加载器
                long t1 = System.nanoTime();
                c = findClass(name);

                //用于统计类加载器相关的信息
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            //对类进行link操作
            resolveClass(c);
        }
        return c;
    }
}
```

简单总结一下双亲委派模型的执行流程：

- 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。
- 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
- 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。
- 如果子类加载器也无法加载这个类，那么它会抛出一个 `ClassNotFoundException` 异常。

**JVM 判定两个 Java 类是否相同的具体规则**：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 `Class` 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。

#### 6.双亲委派的好处

双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。

#### 7.打破双亲委派

自定义加载器的话，需要继承 `ClassLoader` 。如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass()` 方法。

为什么是重写 `loadClass()` 方法打破双亲委派模型

- 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。

### 6.最重要的JVM参数总结

**1.显示指定堆内存-Xms和-Xmx**

```
-Xms<heap size>[unit]
-Xmx<heap size>[unit]
heap size 表示要初始化内存的具体大小。
unit 表示要初始化内存的单位。单位为 “ g” (GB)、“ m”（MB）、“ k”（KB）
```

**2.显示新生代内存（Young Generation)**

```
-XX:NewSize=<young size>[unit]
-XX:MaxNewSize=<young size>[unit]
新生代分配 最小 256m 的内存，最大 1024m
-XX:NewSize=256m
-XX:MaxNewSize=1024m
新生代分配 256m 的内存（NewSize 与 MaxNewSize 设为一致）
-Xmn256m
设置老年代与新生代内存的比值
-XX:NewRatio=1
```

将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。

**3.显式指定永久代/元空间的大小**

```
-XX:PermSize=N #方法区 (永久代) 初始大小
-XX:MaxPermSize=N #方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
-XX:MetaspaceSize=N #设置 Metaspace 的初始大小（是一个常见的误区，后面会解释）
-XX:MaxMetaspaceSize=N #设置 Metaspace 的最大大小
```

**4.垃圾收集相关**

JVM 具有四种类型的 GC 实现：

- 串行垃圾收集器

- 并行垃圾收集器

- CMS 垃圾收集器

- G1 垃圾收集器

  ```
  -XX:+UseSerialGC
  -XX:+UseParallelGC
  -XX:+UseParNewGC
  -XX:+UseG1GC
  ```

**5.GC日志记录**

```
# 必选
# 打印基本 GC 信息
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
# 打印对象分布
-XX:+PrintTenuringDistribution
# 打印堆数据
-XX:+PrintHeapAtGC
# 打印Reference处理信息
# 强引用/弱引用/软引用/虚引用/finalize 相关的方法
-XX:+PrintReferenceGC
# 打印STW时间
-XX:+PrintGCApplicationStoppedTime

# 可选
# 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint
-XX:+PrintSafepointStatistics
-XX:PrintSafepointStatisticsCount=1

# GC日志输出的文件路径
-Xloggc:/path/to/gc-%t.log
# 开启日志文件分割
-XX:+UseGCLogFileRotation
# 最多分割几个文件，超过之后从头文件开始写
-XX:NumberOfGCLogFiles=14
# 每个文件上限大小，超过就触发分割
-XX:GCLogFileSize=50M
```

**6.处理OOM**

```
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=./java_pid<pid>.hprof
-XX:OnOutOfMemoryError="< cmd args >;< cmd args >"
-XX:+UseGCOverheadLimit
```

- **HeapDumpOnOutOfMemoryError** 指示 JVM 在遇到 **OutOfMemoryError** 错误时将 heap 转储到物理文件中。
- **HeapDumpPath** 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 `<pid>` 标记，则当前进程的进程 id 将附加到文件名中，并使用`.hprof`格式
- **OnOutOfMemoryError** 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 `cmd args` 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: `-XX:OnOutOfMemoryError="shutdown -r"` 。
- **UseGCOverheadLimit** 是一种策略，它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例。

**7.其他。**

![image-20240305200522089](C:\Users\Luckylemon\AppData\Roaming\Typora\typora-user-images\image-20240305200522089.png)

### 7.JDK监控和故障处理工具总结

#### 1.JDK命令行工具

 JDK 安装目录下的 bin 目录下：

- **`jps`** (JVM Process Status）: 类似 UNIX 的 `ps` 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；
- **`jstat`**（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;
- **`jinfo`** (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;
- **`jmap`** (Memory Map for Java) : 生成堆转储快照;
- **`jhat`** (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;
- **`jstack`** (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。

**JPS：查看所有JAVA进程**

```
jps：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。
jps -q：只输出进程的本地虚拟机唯一 ID。
jps -l:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。
jps -v：输出虚拟机进程启动时 JVM 参数。
jps -m：输出传递给 Java 进程 main() 函数的参数。
```

**Jstat:监视虚拟机各种运作状态信息**

```
jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]
```

**常见的 option 如下：**

- `jstat -class vmid`：显示 ClassLoader 的相关信息；
- `jstat -compiler vmid`：显示 JIT 编译的相关信息；
- `jstat -gc vmid`：显示与 GC 相关的堆信息；
- `jstat -gccapacity vmid`：显示各个代的容量及使用情况；
- `jstat -gcnew vmid`：显示新生代信息；
- `jstat -gcnewcapcacity vmid`：显示新生代大小与使用情况；
- `jstat -gcold vmid`：显示老年代和永久代的行为统计，从 jdk1.8 开始,该选项仅表示老年代，因为永久代被移除了；
- `jstat -gcoldcapacity vmid`：显示老年代的大小；
- `jstat -gcpermcapacity vmid`：显示永久代大小，从 jdk1.8 开始,该选项不存在了，因为永久代被移除了；
- `jstat -gcutil vmid`：显示垃圾收集信息

**jinfo:实时地查看和调整虚拟机各项参数**

```
jinfo vmid :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。
jinfo -flag name vmid :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( -XX:PrintGCDetails :详细 GC 日志模式，这两个都是默认关闭的)。
jinfo -flag [+|-]name vmid 开启或者关闭对应名称的参数
```

**jmap:生成堆转储快照**

```
jmap（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 jmap 命令，要想获取 Java 堆转储，可以使用 “-XX:+HeapDumpOnOutOfMemoryError” 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 kill -3 发送进程退出信号也能拿到 dump 文件。jmap 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和jinfo一样，jmap有不少功能在 Windows 平台下也是受限制的。
```

**jhat:分析heapdump文件**

**`jhat`** 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。

**jstack:生成虚拟机当前时刻的线程快照**

`jstack`（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.

生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过`jstack`来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。

#### 2.JDK可视化分析工具

**JConsole:JAVA监视与管理控制台**

JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输入`jconsole`命令启动或者在 JDK 目录下的 bin 目录找到`jconsole.exe`然后双击启动。

JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况。

**Visual VM:多合一故障处理工具**

VisualVM 提供在 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的 Java 应用程序的详细信息。

VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：

- **显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。**
- **监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。**
- **dump 以及分析堆转储快照（jmap、jhat）。**
- **方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。**
- **离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。**
- ****其他 plugins 的无限的可能性……**

### 8.JVM线上排查、性能调优

如果没有明显的内存泄漏问题和严重的性能问题，专门调优一些 JVM 参数是非常没有必要的，优化空间也比较小。

所以，我们一般优化的思路有一个重要的顺序：

    程序优化，效果通常非常大；
    
    扩容，如果金钱的成本比较小，不要和自己过不去；
    
    参数调优，在成本、吞吐量、延迟之间找一个平衡点。

我们可以再加一些原则用以辅助完成优化。

    一个长时间的压测是必要的，通常我们使用 JMeter 工具。
    
    如果线上有多个节点，可以把我们的优化在其中几个节点上生效。等优化真正有效果之后再全面推进。
    
    优化过程和目标之间可能是循环的，结果和目标不匹配，要推翻重来。


我们的业务场景是高并发的。对象诞生的快，死亡的也快，对年轻代的利用直接影响了整个堆的垃圾收集。

    足够大的年轻代，会增加系统的吞吐，但不会增加 GC 的负担。
    
    容量足够的 Survivor 区，能够让对象尽可能的留在年轻代，减少对象的晋升，进而减少 Major GC。

我们还看到了一个元空间引起的 Full GC 的过程，这在高并发的场景下影响会格外突出，尤其是对于使用了大量动态类的应用来说。通过调大它的初始值，可以解决这个问题。

### 9.高频面试题！！！

**1.启动程序如何查看加载了哪些类，以及加载顺序？**

java -XX：+TraceClassLoading 具体类

java -verbose 具体类

**2.class字节码文件10个主要组成部分？**

MagicNumber【魔数】：确定这个文件是否为一个能被虚拟机接收的Class文件

Version【版本号】

Constant_pool【常量池】:存放字面量和符号引用

Access_flag【访问标志】:用于识别类或接口层次的访问信息

This_class【当前类】、Super_class【父类】、Interfaces:【接口】

Fields【字段表集合】:用于描述接口或类中声明的变量

Methods【方法表集合】:结构：访问标志、名称索引、描述符索引、属性集合表

Attributrs【属性表集合】:用于描述某些场景专有的信息

**3.什么情况下会出现堆内存溢出？**

堆内存存储对象实例。只要不断地创建对象，并保证GC roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大，堆容量超出限制后，就会产生内存溢出异常。

```
如何实现一个堆内存溢出：
public class Cat{
   public static void main(String[] args){
   List list = new ArrayList();
   while(true){
       list.add(new Cat());
      }
   }
}
```

**4.Edem:from：to默认比例是**

Edem:from：to = 8:1:1  可通过-XX：SurvivorRatio来设定

**5.G1回收器的原理：**

G1垃圾回收器是一种基于区域的垃圾回收器。

其工作原理如下：1、将堆空间划分为多个相同大小的区域。2、在每个区域中，将存活对象和垃圾对象进行标记。3、对于存活对象所占用的内存空间，将其拷贝到空闲的区域中，同时更新其原始引用。4、最后清除所有垃圾对象，释放内存空间以供再次使用。

**6.新生代和老年代如何实现？**

ava虚拟机(JVM)的内存空间主要分为新生代和老年代，这是基于对象的生命周期不同进行的划分。

1. 新生代：新生代主要包括Eden区和两个Survivor区。大部分情况下，新创建的对象都会被分配到Eden区（一些大对象特殊处理），这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。在Survivor区每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度（默认15岁），就会被移动到老年代中。

2. 老年代：存放在新生代中熬过多次Minor GC仍然存活的对象以及一些大对象。通常情况下，对老年代的回收称为Major GC或者Full GC，这种回收通常比Minor GC要慢很多。

新生代和老年代的实现主要是通过内存分配策略和垃圾收集器来实现的。新生代通常采用复制算法进行垃圾回收，而老年代通常使用标记-清除-整理算法进行垃圾回收。

**7.如果创建一个10M的对象，放在新生代还是老年代？**

在Java虚拟机中，对象的大小会影响其分配在堆内存的哪个区域。一般来说，10M 的对象会被认为是比较大的对象。在新生代中，一般会放置较小的对象，而较大的对象会直接分配到老年代。

因此，一个 10M 的对象很可能会直接分配到老年代，而不是放在新生代。这样做可以减少新生代的垃圾回收频率，提高程序的性能。

**8.JVM问题定位的手段**

JVM问题定位主要分为CPU线程锁或者JVM的OOM问题。比较难的是OOM问题的定位，因为还需要区分是不是生产环境。

1.查看线程死锁问题，一般使用jstack命令进行查找：先通过JPS-LM找到所需进程。

2.OOM问题：

**开发环境**：①使用jdk原生命令进行查看②将内存dump出来，然后在jconsole或者Jvisual工具打开观察

**生存环境**：①# 在java启动程序加入该参数，意味着当java程序发生OOM的时候，会在进程挂掉之前，把jvm当前的内存对象保存起来
 -XX:+HeapDumpOnOutOfMemoryError ②在程序发生OOM时候，让运维先别把服务重启，而是马上执行jmap -dump:format=b,file=xxx pid把内存对象导出来。一般这种方式不太推荐，因为一般生产需要马上恢复。但是如果可以dump的话，建议直接dump（或者高可用下，直接执行）

**full gc情况查看**：通常运行命令如下： jps -lm查看对应java进程pid
 jstat -gc 6 3000

**9.JVM堆的分代思想？**

对于一个大型的系统，当创建的对象及方法变量比较多时，即堆内存中的对象比较多，如果逐一分析对象是否该回收，效率很低。分代是为了进行模块化管理，管理不同的对象及变量，以提高 JVM 的执行效率。

　　堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是**为了提高对象内存分配和垃圾回收的效率**。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的GC效率。

　　有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中，**静态属性、类信息等存放在永久代中**，新生代中的对象存活时间短，只需要在新生代区域中频繁进行GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，**还可以根据不同年代的特点采用合适的垃圾收集算法**。分代收集大大提升了收集效率，这些都是内存分代带来的好处。